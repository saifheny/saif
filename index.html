<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Life World - The Absolute King</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; font-family: 'Segoe UI', Tahoma, sans-serif; }
        body, html { width: 100%; height: 100%; overflow: hidden; background-color: #000; position: fixed; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* Start Screen */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; backdrop-filter: blur(10px); color: white; transition: opacity 1s; }
        #start-screen h1 { font-size: 3.5rem; margin-bottom: 5px; color: gold; text-shadow: 0 0 20px rgba(255,215,0,0.8); }
        .btn { background: rgba(20, 20, 20, 0.8); border: 2px solid gold; padding: 15px 40px; color: gold; font-size: 1.3rem; border-radius: 10px; cursor: pointer; font-weight: bold; text-transform: uppercase; box-shadow: 0 0 15px rgba(255,215,0,0.4); }
        .btn:active { background: gold; color: black; transform: scale(0.95); }

        /* HUD */
        .hud-top { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 50; }
        .clock-panel { background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 12px; color: white; font-size: 1.1rem; border: 1px solid gold; font-weight: bold; }
        
        /* Inventory Icon */
        #inventory-btn { width: 55px; height: 55px; background: rgba(0,0,0,0.8); border: 2px solid gold; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.8rem; pointer-events: auto; box-shadow: 0 0 15px rgba(255,215,0,0.6); cursor: pointer; z-index: 60; }
        #inventory-btn:active { transform: scale(0.9); background: gold; }

        /* Inventory Panel */
        #inventory-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; max-width: 320px; background: rgba(10,10,10,0.98); border: 2px solid gold; border-radius: 15px; padding: 25px; color: white; display: none; pointer-events: auto; z-index: 100; box-shadow: 0 0 40px rgba(0,0,0,0.9); }
        .inv-item { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 1.2rem; border-bottom: 1px solid #444; padding-bottom: 8px; font-weight: bold; }

        /* Controls - Fixed Joystick */
        #control-right { position: absolute; bottom: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; z-index: 20; }
        #joystick-zone { position: absolute; bottom: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; z-index: 20; }
        
        #joystick-base { position: absolute; bottom: 40px; left: 40px; width: 130px; height: 130px; background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 215, 0, 0.5); border-radius: 50%; pointer-events: none; z-index: 30; }
        #joystick-stick { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255, 215, 0, 0.8); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 15px rgba(0,0,0,0.8); }

        /* Crosshair & Interaction */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: gold; border-radius: 50%; transform: translate(-50%, -50%); border: 1px solid black; z-index: 40; }
        #context-btn { position: absolute; top: 58%; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); border: 2px solid gold; color: white; padding: 10px 25px; border-radius: 20px; font-size: 1.1rem; font-weight: bold; pointer-events: auto; display: none; box-shadow: 0 0 15px rgba(255,215,0,0.5); z-index: 60; cursor: pointer; }
        #context-btn:active { background: gold; color: black; }

        /* Dialog Menu */
        #dialog-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 2px solid gold; padding: 25px; border-radius: 15px; display: none; pointer-events: auto; color: white; z-index: 100; min-width: 300px; box-shadow: 0 0 30px black; }
        .dialog-title { font-size: 1.5rem; margin-bottom: 20px; text-align: center; border-bottom: 2px solid gold; padding-bottom: 10px; font-weight: bold; color: gold; }
        .dialog-btn { width: 100%; margin-bottom: 10px; background: #222; border: 1px solid gold; padding: 12px; color: white; border-radius: 8px; font-size: 1.1rem; font-weight: bold; cursor: pointer; }
        .dialog-btn:active { background: gold; color: black; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <div id="start-screen">
            <h1>ÿπÿµÿ± ÿßŸÑŸÖŸÑŸàŸÉ</h1>
            <p style="margin-bottom: 30px; color: #ddd; font-size: 1.2rem;">ÿ£ŸÜÿ™ ÿßŸÑŸÖŸÑŸÉ ÿßŸÑŸÖÿ∑ŸÑŸÇ. ÿßŸÑŸÇÿµÿ± ŸàÿßŸÑŸÖÿØŸäŸÜÿ© ŸÖŸÑŸÉŸÉ.</p>
            <button class="btn" id="start-btn">ÿØÿÆŸàŸÑ ÿßŸÑŸÖŸÖŸÑŸÉÿ©</button>
        </div>

        <div id="hud" style="display:none;">
            <div class="hud-top">
                <div class="clock-panel" id="time-display">‚è∞ 08:00 ÿµÿ®ÿßÿ≠ÿßŸã</div>
                <div id="inventory-btn">üéí</div>
            </div>
            
            <div id="crosshair"></div>
            <button id="context-btn">ÿ™ŸÅÿßÿπŸÑ</button>

            <!-- Controls -->
            <div id="joystick-zone"></div>
            <div id="control-right"></div>
            <div id="joystick-base"><div id="joystick-stick"></div></div>
        </div>

        <!-- Inventory -->
        <div id="inventory-panel">
            <h3 style="text-align:center; color:gold; margin-bottom:20px; border-bottom:2px solid gold; padding-bottom:10px;">ÿ≠ŸÇŸäÿ®ÿ© ÿßŸÑŸÖŸÑŸÉ</h3>
            <div class="inv-item"><span>üí∞ ÿßŸÑŸÖÿßŸÑ:</span> <span id="inv-money">5000$</span></div>
            <div class="inv-item"><span>‚ù§Ô∏è ÿßŸÑÿµÿ≠ÿ©:</span> <span id="inv-hp">100</span></div>
            <div class="inv-item"><span>ü™µ ÿßŸÑÿÆÿ¥ÿ®:</span> <span id="inv-wood">50</span></div>
            <div class="inv-item"><span>üçé ÿßŸÑÿ∑ÿπÿßŸÖ:</span> <span id="inv-food">100</span></div>
            <button class="dialog-btn" style="margin-top:20px; background:red; border-color:darkred;" onclick="document.getElementById('inventory-panel').style.display='none'">ÿ•ÿ∫ŸÑÿßŸÇ</button>
        </div>

        <!-- Dialog -->
        <div id="dialog-menu">
            <div class="dialog-title" id="dialog-title">ÿ¥ÿÆÿµŸäÿ©</div>
            <div id="dialog-actions"></div>
            <button class="dialog-btn" style="margin-top:15px; background:red; border-color:darkred;" onclick="document.getElementById('dialog-menu').style.display='none'">ÿ•ŸÑÿ∫ÿßÿ°</button>
        </div>
    </div>

<script>
// Procedural Textures
const TextureGen = {
    createGrass: () => {
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#2e5c1e'; ctx.fillRect(0,0,512,512);
        for(let i=0; i<3000; i++) { ctx.fillStyle = Math.random()>0.5 ? '#3a7a24' : '#1e3d13'; ctx.fillRect(Math.random()*512, Math.random()*512, 3, 3); }
        const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(60,60); return tex;
    },
    createWall: () => {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#d0c0b0'; ctx.fillRect(0,0,256,256);
        ctx.fillStyle = '#a09080';
        for(let y=0; y<256; y+=32) {
            ctx.fillRect(0, y, 256, 3);
            for(let x=0; x<256; x+=64) { ctx.fillRect(x + ((y/32)%2==0?0:32), y, 3, 32); }
        }
        return new THREE.CanvasTexture(canvas);
    }
};

const Textures = { grass: TextureGen.createGrass(), wall: TextureGen.createWall() };
Textures.wall.wrapS = Textures.wall.wrapT = THREE.RepeatWrapping; Textures.wall.repeat.set(2,2);

const Materials = {
    grass: new THREE.MeshStandardMaterial({ map: Textures.grass, roughness: 1.0 }),
    wall: new THREE.MeshStandardMaterial({ map: Textures.wall, roughness: 0.9 }),
    // Shiny Gold and Diamond materials for Palace
    palaceGold: new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 }),
    palaceDiamond: new THREE.MeshStandardMaterial({ color: 0xe0ffff, metalness: 0.8, roughness: 0.0, transparent: true, opacity: 0.9 }),
    redCarpet: new THREE.MeshStandardMaterial({ color: 0x990000, roughness: 1.0 }),
    wood: new THREE.MeshStandardMaterial({ color: 0x4a3018, roughness: 0.9 }),
    skin: new THREE.MeshStandardMaterial({ color: 0xffe0bd }),
    hairDark: new THREE.MeshStandardMaterial({ color: 0x111111 }),
    clothServant: new THREE.MeshStandardMaterial({ color: 0xeeeeee }),
    clothCity: new THREE.MeshStandardMaterial({ color: 0xaa5566 }),
    door: new THREE.MeshStandardMaterial({ color: 0x3d2314 }),
    bed: new THREE.MeshStandardMaterial({ color: 0x224488 })
};

const PlayerStats = { hp: 100, money: 5000, wood: 50, food: 100 };

class Game {
    constructor() {
        this.time = 8; this.timeSpeed = 0.004; 
        this.npcs = []; this.autoDoors = []; this.interactables = [];
        this.joystick = { x: 0, y: 0 }; this.look = { yaw: 0, pitch: 0, tYaw: 0, tPitch: 0 };
        
        this.initThree(); this.initPhysics();
        this.buildWorld(); this.initPlayer();
        this.initControls(); this.initUI();
        
        document.getElementById('start-btn').onclick = () => {
            document.getElementById('start-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                if(navigator.vibrate) navigator.vibrate(50);
                requestAnimationFrame(this.animate.bind(this));
            }, 500);
        };
    }

    initThree() {
        this.canvas = document.getElementById('game-canvas');
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: false, powerPreference: "high-performance" });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        this.scene = new THREE.Scene(); this.scene.background = new THREE.Color(0x87CEEB);
        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 400);

        this.hemiLight = new THREE.HemisphereLight(0xffffff, 0x444455, 0.6); this.scene.add(this.hemiLight);
        this.dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        this.dirLight.castShadow = true;
        this.dirLight.shadow.camera.top = 150; this.dirLight.shadow.camera.bottom = -150;
        this.dirLight.shadow.camera.left = -150; this.dirLight.shadow.camera.right = 150;
        this.dirLight.shadow.mapSize.width = 1024; this.dirLight.shadow.mapSize.height = 1024;
        this.scene.add(this.dirLight);

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth/window.innerHeight; this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    initPhysics() {
        this.world = new CANNON.World(); this.world.gravity.set(0, -20, 0);
        this.world.broadphase = new CANNON.NaiveBroadphase();
        this.physicsMaterial = new CANNON.Material("standard");
        this.world.addContactMaterial(new CANNON.ContactMaterial(this.physicsMaterial, this.physicsMaterial, { friction: 0.1, restitution: 0.0 }));
    }

    addPhysicsBox(x,y,z, sx,sy,sz) {
        const body = new CANNON.Body({ mass: 0, material: this.physicsMaterial });
        body.addShape(new CANNON.Box(new CANNON.Vec3(sx/2, sy/2, sz/2)));
        body.position.set(x, y, z); this.world.addBody(body);
        return body;
    }

    buildWorld() {
        // Ground
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), Materials.grass);
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; this.scene.add(ground);
        const gBody = new CANNON.Body({ mass: 0, material: this.physicsMaterial });
        gBody.addShape(new CANNON.Plane()); gBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
        this.world.addBody(gBody);

        this.buildPalace();
        
        // City Houses & NPCs
        const cityLocations = [ {x: 80, z: 80}, {x: -80, z: 80}, {x: 80, z: -80}, {x: -80, z: -80}, {x: 100, z: 0}, {x: -100, z: 0} ];
        cityLocations.forEach((loc, i) => {
            this.buildHouse(loc.x, loc.z);
            
            const homeInside = new THREE.Vector3(loc.x, 0, loc.z);
            const homeDoor = new THREE.Vector3(loc.x, 0, loc.z + 10);
            
            // Spawn Husband and Wife, and link them!
            let wife = this.spawnNPC(loc.x+5, 0, loc.z+15, 'female', homeInside, homeDoor);
            let husband = this.spawnNPC(loc.x-5, 0, loc.z+15, 'male', homeInside, homeDoor);
            husband.wife = wife; // Link for inheritance logic
        });
    }

    createWallWithHole(px, py, pz, width, height, depth, holeWidth, holeHeight, material) {
        const group = new THREE.Group(); group.position.set(px, py, pz);
        const sideW = (width - holeWidth) / 2;
        const left = new THREE.Mesh(new THREE.BoxGeometry(sideW, height, depth), material);
        left.position.set(-width/2 + sideW/2, 0, 0); left.castShadow = true; left.receiveShadow = true; group.add(left);
        this.addPhysicsBox(px + left.position.x, py, pz, sideW, height, depth);
        const right = new THREE.Mesh(new THREE.BoxGeometry(sideW, height, depth), material);
        right.position.set(width/2 - sideW/2, 0, 0); right.castShadow = true; right.receiveShadow = true; group.add(right);
        this.addPhysicsBox(px + right.position.x, py, pz, sideW, height, depth);
        const topH = height - holeHeight;
        if(topH > 0) {
            const top = new THREE.Mesh(new THREE.BoxGeometry(holeWidth, topH, depth), material);
            top.position.set(0, height/2 - topH/2, 0); top.castShadow = true; top.receiveShadow = true; group.add(top);
            this.addPhysicsBox(px, py + top.position.y, pz, holeWidth, topH, depth);
        }
        this.scene.add(group);
        return group;
    }

    createAutoDoor(x, y, z, width, height, isDouble = false, rotY = 0) {
        const pivot = new THREE.Group(); pivot.position.set(x, y, z); pivot.rotation.y = rotY; this.scene.add(pivot);
        if(!isDouble) {
            const door = new THREE.Mesh(new THREE.BoxGeometry(width, height, 0.5), Materials.door);
            door.position.set(width/2, height/2, 0); door.castShadow = true; pivot.add(door);
            this.autoDoors.push({ pivot: pivot, type: 'single', closed: 0, open: Math.PI/2, meshPos: new THREE.Vector3(x,y,z) });
        } else {
            const doorL = new THREE.Mesh(new THREE.BoxGeometry(width/2, height, 1), Materials.wood);
            doorL.position.set(-width/4, height/2, 0); doorL.castShadow = true; pivot.add(doorL);
            const doorR = new THREE.Mesh(new THREE.BoxGeometry(width/2, height, 1), Materials.wood);
            doorR.position.set(width/4, height/2, 0); doorR.castShadow = true; pivot.add(doorR);
            this.autoDoors.push({ pivot: pivot, type: 'slide', closed: 0, open: width/2, doorL: doorL, doorR: doorR, meshPos: new THREE.Vector3(x,y,z) });
        }
    }

    buildHouse(x, z) {
        const w=16, h=8, d=16, t=1;
        // Walls
        const m1 = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), Materials.wall); m1.position.set(x, h/2, z-d/2); this.scene.add(m1); this.addPhysicsBox(x, h/2, z-d/2, w, h, t);
        const m2 = new THREE.Mesh(new THREE.BoxGeometry(t, h, d), Materials.wall); m2.position.set(x-w/2, h/2, z); this.scene.add(m2); this.addPhysicsBox(x-w/2, h/2, z, t, h, d);
        const m3 = new THREE.Mesh(new THREE.BoxGeometry(t, h, d), Materials.wall); m3.position.set(x+w/2, h/2, z); this.scene.add(m3); this.addPhysicsBox(x+w/2, h/2, z, t, h, d);
        this.createWallWithHole(x, h/2, z+d/2, w, h, t, 4, 6, Materials.wall);
        this.createAutoDoor(x-2, 0, z+d/2, 4, 6, false);

        // Furnishings
        const carpet = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), Materials.redCarpet);
        carpet.rotation.x = -Math.PI/2; carpet.position.set(x, 0.1, z); this.scene.add(carpet);
        
        const bed = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 6), Materials.bed);
        bed.position.set(x - w/2 + 3, 0.75, z - d/2 + 4); this.scene.add(bed);

        const table = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), Materials.wood);
        table.position.set(x + w/2 - 3, 1, z - d/2 + 3); this.scene.add(table);

        // Roof
        const roof = new THREE.Mesh(new THREE.ConeGeometry(14, 6, 4), new THREE.MeshStandardMaterial({color: 0x553322}));
        roof.position.set(x, h+3, z); roof.rotation.y = Math.PI/4; roof.castShadow = true; this.scene.add(roof);
    }

    buildPalace() {
        const px = 0, pz = 0, size = 110, h = 16, t = 2;
        
        // Outer Walls (Diamond & Gold)
        const mB = new THREE.Mesh(new THREE.BoxGeometry(size, h, t), Materials.palaceDiamond); mB.position.set(px, h/2, pz-size/2); this.scene.add(mB); this.addPhysicsBox(px, h/2, pz-size/2, size, h, t);
        const mL = new THREE.Mesh(new THREE.BoxGeometry(t, h, size), Materials.palaceGold); mL.position.set(px-size/2, h/2, pz); this.scene.add(mL); this.addPhysicsBox(px-size/2, h/2, pz, t, h, size);
        const mR = new THREE.Mesh(new THREE.BoxGeometry(t, h, size), Materials.palaceGold); mR.position.set(px+size/2, h/2, pz); this.scene.add(mR); this.addPhysicsBox(px+size/2, h/2, pz, t, h, size);
        this.createWallWithHole(px, h/2, pz+size/2, size, h, t, 16, 10, Materials.palaceGold);
        this.createAutoDoor(px, 0, pz+size/2, 16, 10, true);

        // Grand Red Carpet in courtyard
        const mainCarpet = new THREE.Mesh(new THREE.PlaneGeometry(16, size), Materials.redCarpet);
        mainCarpet.rotation.x = -Math.PI/2; mainCarpet.position.set(0, 0.1, 0); this.scene.add(mainCarpet);

        // Grand King's Bedroom (At the far back of the palace)
        const bedRoomSize = 30;
        const bWall = new THREE.Mesh(new THREE.BoxGeometry(bedRoomSize, h, t), Materials.palaceDiamond); bWall.position.set(0, h/2, -size/2 + bedRoomSize); this.scene.add(bWall); this.addPhysicsBox(0, h/2, -size/2 + bedRoomSize, bedRoomSize, h, t);
        
        // Massive Golden Bed in King's Room
        const grandBed = new THREE.Mesh(new THREE.BoxGeometry(10, 2, 14), Materials.palaceGold);
        grandBed.position.set(0, 1, -size/2 + 10); this.scene.add(grandBed);
        const mattress = new THREE.Mesh(new THREE.BoxGeometry(9, 1, 13), Materials.redCarpet);
        mattress.position.set(0, 2.5, -size/2 + 10); this.scene.add(mattress);

        // Spawn 18 Servants (Harem/Maids) in the Palace
        for(let i=0; i<18; i++) {
            let sx = (Math.random()-0.5) * 80;
            let sz = (Math.random()-0.5) * 80;
            this.spawnNPC(sx, 0, sz, 'servant', new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,20));
        }
    }

    spawnNPC(x, y, z, type, homeInside, homeDoor) {
        const group = new THREE.Group(); group.position.set(x,y,z);
        let isFemale = (type === 'female' || type === 'servant');
        let mat = type === 'servant' ? Materials.clothServant : (isFemale ? Materials.clothCity : Materials.wood);
        
        const body = new THREE.Mesh(new THREE.BoxGeometry(isFemale?0.8:1.2, 1.3, 0.6), mat);
        body.position.y = 1.2; body.castShadow = true; group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), Materials.skin);
        head.position.y = 2.1; head.castShadow = true; group.add(head);
        if(isFemale) { const hair = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.4, 0.5), Materials.hairDark); hair.position.set(0,1.8,-0.1); group.add(hair); }
        
        this.scene.add(group);
        const hitBox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 1.5), new THREE.MeshBasicMaterial({visible:false}));
        hitBox.position.y = 1.2; group.add(hitBox);

        const npc = {
            mesh: group, type: type, hp: 100, 
            homeInside: homeInside, homeDoor: homeDoor,
            target: new THREE.Vector3(x,0,z), state: 'wander',
            isDead: false, timer: 0, wife: null
        };

        hitBox.userData = {
            actionName: 'ÿ™ŸÅÿßÿπŸÑ',
            interact: () => { if(!npc.isDead) this.openDialog(npc); }
        };
        this.interactables.push(hitBox); this.npcs.push(npc);
        return npc;
    }

    initPlayer() {
        this.pBody = new CANNON.Body({ mass: 70, material: this.physicsMaterial, shape: new CANNON.Sphere(0.6), linearDamping: 0.9, fixedRotation: true });
        this.pBody.position.set(0, 5, 80); 
        this.world.addBody(this.pBody);
        
        this.pGroup = new THREE.Group(); this.scene.add(this.pGroup);
        this.camera.position.set(0, 1.8, 0); this.pGroup.add(this.camera);
        this.raycaster = new THREE.Raycaster();
    }

    initControls() {
        const jZone = document.getElementById('joystick-zone');
        const jStick = document.getElementById('joystick-stick');
        let isDrag = false;
        
        jZone.addEventListener('touchstart', (e) => { isDrag = true; this.handleJoy(e.touches[0]); });
        jZone.addEventListener('touchmove', (e) => {
            if(isDrag) {
                for(let i=0; i<e.touches.length; i++) {
                    if(e.touches[i].clientX < window.innerWidth/2) { this.handleJoy(e.touches[i]); break; }
                }
            }
        });
        const endJoy = () => { isDrag=false; jStick.style.transform=`translate(-50%,-50%)`; this.joystick={x:0,y:0}; };
        jZone.addEventListener('touchend', endJoy); jZone.addEventListener('touchcancel', endJoy);

        const rZone = document.getElementById('control-right'); let lastT = null;
        rZone.addEventListener('touchstart', e => { 
            for(let i=0; i<e.touches.length; i++) { if(e.touches[i].clientX >= window.innerWidth/2) { lastT = {x: e.touches[i].clientX, y: e.touches[i].clientY}; break; } }
        });
        rZone.addEventListener('touchmove', e => {
            if(!lastT) return;
            for(let i=0; i<e.touches.length; i++) {
                if(e.touches[i].clientX >= window.innerWidth/2) {
                    const t = e.touches[i];
                    this.look.tYaw -= (t.clientX - lastT.x)*0.005;
                    this.look.tPitch -= (t.clientY - lastT.y)*0.005;
                    this.look.tPitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, this.look.tPitch));
                    lastT = {x: t.clientX, y: t.clientY}; break;
                }
            }
        });
        rZone.addEventListener('touchend', () => lastT=null);

        document.getElementById('inventory-btn').onclick = (e) => {
            e.stopPropagation();
            document.getElementById('inventory-panel').style.display = 'block';
            document.getElementById('inv-money').innerText = PlayerStats.money + '$';
            document.getElementById('inv-hp').innerText = PlayerStats.hp;
            if(navigator.vibrate) navigator.vibrate(20);
        };
        document.getElementById('context-btn').onclick = (e) => { e.preventDefault(); if(this.curObj) this.curObj.userData.interact(); };
    }

    handleJoy(t) {
        const base = document.getElementById('joystick-base').getBoundingClientRect();
        const cX = base.left + base.width/2; const cY = base.top + base.height/2;
        let dx = t.clientX - cX, dy = t.clientY - cY, dist = Math.sqrt(dx*dx+dy*dy);
        const max = base.width/2 - 10;
        if(dist > max) { dx = (dx/dist)*max; dy = (dy/dist)*max; }
        document.getElementById('joystick-stick').style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        this.joystick = {x: dx/max, y: dy/max};
    }

    initUI() { setInterval(() => {
        this.time += this.timeSpeed; if(this.time >= 24) this.time = 0;
        let h = Math.floor(this.time), m = Math.floor((this.time-h)*60);
        document.getElementById('time-display').innerText = `‚è∞ ${h%12||12}:${m<10?'0':''}${m} ${h>=12?'ŸÖÿ≥ÿßÿ°Ÿã':'ÿµÿ®ÿßÿ≠ÿßŸã'}`;
        
        let isNight = this.time > 18 || this.time < 6;
        this.scene.background.setHex(isNight ? 0x050515 : 0x87CEEB);
        this.dirLight.intensity = isNight ? 0.0 : 1.2;
    }, 100); }

    openDialog(npc) {
        const menu = document.getElementById('dialog-menu'), acts = document.getElementById('dialog-actions');
        document.getElementById('dialog-title').innerText = npc.type==='servant' ? 'ÿ¨ÿßÿ±Ÿäÿ© ÿßŸÑŸÇÿµÿ±' : (npc.type==='female' ? 'ÿ±ÿπŸäÿ© ŸÖŸÜ ŸÜÿ≥ÿßÿ° ÿßŸÑŸÖÿØŸäŸÜÿ©' : 'ÿ±ÿ¨ŸÑ ŸÖŸÜ ÿπÿßŸÖÿ© ÿßŸÑÿ¥ÿπÿ®');
        acts.innerHTML = '';
        const btn = (txt, fn) => { let b = document.createElement('button'); b.className='dialog-btn'; b.innerText=txt; b.onclick=()=>{fn();menu.style.display='none';}; acts.appendChild(b); };

        if(npc.type === 'male') {
            btn('ü§ù ÿ£ŸàÿßŸÖÿ± ŸÖŸÑŸÉŸäÿ© (ÿ™ÿ≠ÿØÿ´)', () => { alert("ÿ≥ŸÖÿπÿßŸã Ÿàÿ∑ÿßÿπÿ© Ÿäÿß ŸÖŸàŸÑÿßŸä ÿßŸÑŸÖŸÑŸÉ."); });
            btn('‚öîÔ∏è ÿ•ÿπÿØÿßŸÖ ŸàŸÖÿµÿßÿØÿ±ÿ© ÿ£ŸÖŸÑÿßŸÉŸá Ÿàÿ≤Ÿàÿ¨ÿ™Ÿá', () => { 
                npc.isDead = true; npc.mesh.rotation.x = Math.PI/2; npc.mesh.position.y = 0.5; 
                PlayerStats.money += 1000; 
                
                // Transfer Wife to Palace and turn into Servant
                if(npc.wife && !npc.wife.isDead) {
                    npc.wife.type = 'servant';
                    npc.wife.mesh.children[0].material = Materials.clothServant; // Change clothes
                    npc.wife.homeInside = new THREE.Vector3(0, 0, 0); // Palace
                    npc.wife.homeDoor = new THREE.Vector3(0, 0, 20);
                    // Spawn a daughter servant
                    this.spawnNPC(0, 0, 0, 'servant', new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,20));
                }
                alert("ÿ™ŸÖ ÿßŸÑÿ•ÿπÿØÿßŸÖ! ÿ£ÿÆÿ∞ÿ™ ŸÖŸÜÿ≤ŸÑŸá Ÿàÿ£ŸÖŸàÿßŸÑŸáÿå Ÿàÿ£ÿµÿ®ÿ≠ÿ™ ÿ≤Ÿàÿ¨ÿ™Ÿá ŸÖŸÜ ÿ¨Ÿàÿßÿ±ŸäŸÉ Ÿàÿ™ŸÖ ŸÜŸÇŸÑŸáÿß ŸÑŸÑŸÇÿµÿ± ŸÖÿπ ÿßÿ®ŸÜÿ™Ÿáÿß."); 
            });
        } else if (npc.type === 'servant') {
            btn('ÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÇÿµÿ± (ÿ™ÿ≠ÿØÿ´)', () => { alert("ŸÜÿ≠ŸÜ ŸÅŸä ÿÆÿØŸÖÿ™ŸÉ Ÿäÿß ÿ¨ŸÑÿßŸÑÿ© ÿßŸÑŸÖŸÑŸÉ."); });
        } else {
            btn('ÿ™ÿ≠ÿØÿ´ ŸÖÿπŸáÿß', () => { alert("ÿπÿßÿ¥ ÿßŸÑŸÖŸÑŸÉ!"); });
        }
        menu.style.display = 'block';
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        const dt = 1/60;

        // Camera & Movement
        this.look.yaw += (this.look.tYaw - this.look.yaw)*0.2; this.look.pitch += (this.look.tPitch - this.look.pitch)*0.2;
        const fwd = -this.joystick.y, rgt = this.joystick.x, spd = 16;
        this.pBody.velocity.x = (rgt*Math.cos(this.look.yaw) + fwd*Math.sin(this.look.yaw))*spd;
        this.pBody.velocity.z = (-rgt*Math.sin(this.look.yaw) + fwd*Math.cos(this.look.yaw))*spd;
        this.world.step(dt);
        this.pGroup.position.copy(this.pBody.position); this.pGroup.rotation.y = this.look.yaw; this.camera.rotation.x = this.look.pitch;

        // Auto Doors Logic
        this.autoDoors.forEach(door => {
            let minDist = door.meshPos.distanceTo(this.pGroup.position);
            this.npcs.forEach(n => { if(!n.isDead) minDist = Math.min(minDist, n.mesh.position.distanceTo(door.meshPos)); });
            
            let isOpen = minDist < 8;
            if(door.type === 'single') { door.pivot.rotation.y += ((isOpen ? door.open : door.closed) - door.pivot.rotation.y) * 0.1; } 
            else if(door.type === 'slide') {
                door.doorL.position.x += ((isOpen ? -door.open : -door.open/2) - door.doorL.position.x) * 0.1;
                door.doorR.position.x += ((isOpen ? door.open : door.open/2) - door.doorR.position.x) * 0.1;
            }
        });

        // Context Btn
        this.raycaster.setFromCamera(new THREE.Vector2(0,0), this.camera);
        const hits = this.raycaster.intersectObjects(this.interactables, false);
        const cBtn = document.getElementById('context-btn');
        if(hits.length>0 && hits[0].distance<6) { this.curObj = hits[0].object; cBtn.style.display='block'; cBtn.innerText = this.curObj.userData.actionName; } 
        else { this.curObj = null; cBtn.style.display='none'; }

        // AI Logic
        let isNight = this.time > 18 || this.time < 6;
        this.npcs.forEach(n => {
            if(n.isDead) return;

            // KING AURA: Everyone respects the King
            let distToKing = n.mesh.position.distanceTo(this.pGroup.position);
            if(distToKing < 15) {
                n.mesh.lookAt(this.pGroup.position.x, n.mesh.position.y, this.pGroup.position.z);
                return; // HALT AND RESPECT
            }

            n.timer -= dt;
            let target = n.target;

            if(n.type === 'servant') {
                // Servants stay inside Palace bounds
                if(n.timer <= 0) {
                    target.set((Math.random()-0.5)*100, 0, (Math.random()-0.5)*100);
                    n.timer = 4 + Math.random()*5;
                }
            } else {
                // Citizens logic
                if(isNight) {
                    let dInside = n.mesh.position.distanceTo(n.homeInside);
                    if(dInside > 5) target.copy(n.homeDoor);
                    if(n.mesh.position.distanceTo(n.homeDoor) < 3) target.copy(n.homeInside);
                } else {
                    if(n.timer <= 0) {
                        target.set((Math.random()-0.5)*200, 0, (Math.random()-0.5)*200);
                        n.timer = 5 + Math.random()*5;
                    }
                }
                // Keep citizens out of Palace
                if (Math.abs(target.x) < 55 && Math.abs(target.z) < 55) {
                    target.x = target.x > 0 ? 60 : -60;
                }
            }

            const dir = new THREE.Vector3().subVectors(target, n.mesh.position); dir.y = 0;
            if(dir.length() > 1) {
                dir.normalize();
                n.mesh.position.addScaledVector(dir, 3 * dt);
                n.mesh.rotation.y = Math.atan2(dir.x, dir.z);
            }
        });

        this.renderer.render(this.scene, this.camera);
    }
}

window.onload = () => new Game();
</script>
</body>
</html>
