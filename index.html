<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù„ÙƒÙŠØ©</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            user-select: none; -webkit-user-select: none; 
        }
        
        #canvas-container { width: 100vw; height: 100vh; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØµÙˆÙŠØ¨ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 2px;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.8);
        }
        #crosshair::before { 
            width: 2px; height: 8px; left: 50%; top: 50%; 
            transform: translate(-50%, -50%); 
        }
        #crosshair::after { 
            width: 8px; height: 2px; left: 50%; top: 50%; 
            transform: translate(-50%, -50%); 
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª */
        #hotbar-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px; border-radius: 8px; display: flex; gap: 6px; 
            pointer-events: auto; border: 2px solid rgba(255,255,255,0.3);
        }
        .slot {
            width: 50px; height: 50px; border: 2px solid #555; 
            background-size: cover; cursor: pointer; transition: all 0.15s;
            position: relative; border-radius: 4px; background-color: #333;
        }
        .slot.active { 
            border-color: #fff; transform: scale(1.1); 
        }
        .slot:hover:not(.active) { 
            border-color: #888;
        }
        .slot span {
            position: absolute; bottom: 2px; right: 4px; color: #fff; 
            font-size: 12px; font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª - Ù…Ø¨Ø³Ø·Ø© */
        #info-panel {
            position: absolute; top: 15px; right: 15px; 
            color: white; text-align: right; font-size: 14px; font-weight: 500;
            background: rgba(0,0,0,0.6);
            padding: 12px 16px; border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #info-panel div { 
            margin: 4px 0; 
            text-shadow: 1px 1px 2px #000;
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø© */
        #health-bar {
            position: absolute; bottom: 85px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 24px; background: rgba(0,0,0,0.7);
            border: 2px solid #333; border-radius: 4px; overflow: hidden;
        }
        #health-fill {
            height: 100%; background: #c43a3a;
            transition: width 0.3s; width: 100%;
        }
        #health-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 14px;
            text-shadow: 1px 1px 2px #000;
        }

        /* Ù…Ø¤Ø´Ø± Ø§Ù„ÙƒØ³Ø± */
        #break-progress {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, calc(-50% + 40px));
            width: 200px; height: 8px; background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 4px;
            overflow: hidden; display: none;
        }
        #break-fill {
            height: 100%; background: #fff; width: 0%;
            transition: width 0.05s linear;
        }

        /* Ù†Ø§ÙØ°Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© */
        #npc-info-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.95);
            padding: 25px; border-radius: 8px; display: none;
            border: 2px solid rgba(255,255,255,0.3); pointer-events: auto;
            min-width: 350px; max-width: 450px;
        }
        #npc-info-modal h2 {
            color: #fff; margin-bottom: 20px; text-align: center;
            font-size: 20px; text-shadow: 1px 1px 2px #000;
        }
        #npc-info-modal .info-row {
            margin: 10px 0; font-size: 15px; color: white;
            display: flex; justify-content: space-between;
            padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px;
        }
        #npc-info-modal .info-row .label { color: #ddd; font-weight: 500; }
        #npc-info-modal .close-btn {
            margin-top: 20px; padding: 10px 25px; background: #555;
            color: white; border: none; border-radius: 4px; cursor: pointer;
            font-size: 15px; font-weight: 500; width: 100%;
            transition: all 0.2s;
        }
        #npc-info-modal .close-btn:hover { background: #666; }
        #npc-info-modal .action-btn {
            margin-top: 8px; padding: 10px 25px; background: #888;
            color: #fff; border: none; border-radius: 4px; cursor: pointer;
            font-size: 15px; font-weight: 500; width: 100%;
            transition: all 0.2s;
        }
        #npc-info-modal .action-btn:hover { background: #999; }

        /* Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; 
            align-items: center; color: white; pointer-events: auto; z-index: 100;
        }
        #overlay h1 {
            color: #fff; font-size: 42px; margin-bottom: 15px;
            text-shadow: 2px 2px 4px #000;
        }
        #overlay p {
            font-size: 16px; margin: 6px 0; text-align: center;
            max-width: 600px; line-height: 1.5; color: #ccc;
        }
        #start-btn {
            padding: 15px 50px; font-size: 20px; cursor: pointer; 
            background: #555;
            color: #fff; border: none; border-radius: 6px; margin-top: 25px;
            transition: all 0.2s; font-weight: 500;
        }
        #start-btn:hover { background: #666; }
        #start-btn:active { transform: scale(0.98); }

        /* Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ - Ø¨Ø³ÙŠØ·Ø© ÙˆÙ‡Ø§Ø¯Ø¦Ø© */
        #notification {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); color: #fff; padding: 15px 30px;
            border-radius: 6px; font-size: 16px; font-weight: 500;
            border: 1px solid rgba(255,255,255,0.2); display: none; pointer-events: none;
            text-align: center; max-width: 80%;
        }

        /* Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ */
        .joystick-zone {
            position: absolute; bottom: 50px; width: 140px; height: 140px;
            background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(255,255,255,0.02));
            border-radius: 50%; pointer-events: auto; display: none;
            border: 2px solid rgba(255,255,255,0.2);
        }
        #joystick-left { left: 30px; }
        #joystick-right { right: 30px; }
        .stick {
            width: 60px; height: 60px; 
            background: rgba(255,255,255,0.5);
            border-radius: 50%; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #jump-btn, #fly-btn, #attack-btn {
            position: absolute; width: 70px; height: 70px;
            background: rgba(255,255,255,0.3); border-radius: 50%; color: white;
            display: none; justify-content: center; align-items: center; 
            pointer-events: auto; font-size: 14px; font-weight: 500;
            border: 2px solid rgba(255,255,255,0.4);
        }
        #jump-btn { bottom: 200px; right: 30px; }
        #fly-btn { bottom: 200px; left: 30px; }
        #attack-btn { bottom: 110px; right: 110px; }

        @media (hover: none) and (pointer: coarse) {
            .joystick-zone, #jump-btn, #fly-btn, #attack-btn { display: flex; }
            #info-panel { font-size: 12px; padding: 10px; }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="game-ui">
        <div id="crosshair"></div>
        
        <div id="info-panel">
            <div>â° <span id="time-display">ØµØ¨Ø§Ø­</span></div>
            <div>ğŸ’‘ Ø²ÙˆØ¬Ø§Øª: <span id="wives-count">0</span></div>
        </div>

        <div id="health-bar">
            <div id="health-fill"></div>
            <div id="health-text">â¤ï¸ 100 / 100</div>
        </div>

        <div id="break-progress">
            <div id="break-fill"></div>
        </div>
        
        <div id="hotbar-container"></div>

        <div id="joystick-left" class="joystick-zone"><div class="stick"></div></div>
        <div id="joystick-right" class="joystick-zone"><div class="stick"></div></div>
        <div id="jump-btn">â¬†ï¸</div>
        <div id="fly-btn">ğŸ¦…</div>
        <div id="attack-btn">âš”ï¸</div>

        <div id="notification"></div>

        <div id="npc-info-modal">
            <h2 id="npc-modal-title">Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©</h2>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø§Ø³Ù…:</span>
                <span id="npc-name"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø¬Ù†Ø³:</span>
                <span id="npc-gender"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø­Ø§Ù„Ø©:</span>
                <span id="npc-status"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø²ÙˆØ¬/Ø©:</span>
                <span id="npc-spouse"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„ØµØ­Ø©:</span>
                <span id="npc-health"></span>
            </div>
            <button class="action-btn" id="marry-btn" style="display:none;">ğŸ’‘ Ø§Ù„Ø²ÙˆØ§Ø¬</button>
            <button class="action-btn" id="attack-npc-btn">âš”ï¸ Ù…Ù‡Ø§Ø¬Ù…Ø©</button>
            <button class="close-btn" id="close-modal-btn">Ø¥ØºÙ„Ø§Ù‚</button>
        </div>
    </div>

    <div id="overlay">
        <h1>ğŸ° Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù„ÙƒÙŠØ©</h1>
        <p><strong>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…Ù…Ù„ÙƒØªÙƒ!</strong></p>
        <p>ğŸ° Ù…Ø¯ÙŠÙ†Ø© Ù…Ø­ØµÙ†Ø© | ğŸŒ™ Ù†Ø¸Ø§Ù… ÙŠÙˆÙ…/Ù„ÙŠÙ„ | ğŸ‘¥ Ø³ÙƒØ§Ù† Ø£Ø°ÙƒÙŠØ§Ø¡ | ğŸ’‘ Ù†Ø¸Ø§Ù… Ø²ÙˆØ§Ø¬ ÙˆØ¹Ø§Ø¦Ù„Ø§Øª</p>
        <p>âš”ï¸ Ù‚ØªØ§Ù„ Ø§Ù„ÙˆØ­ÙˆØ´ | ğŸšª Ø£Ø¨ÙˆØ§Ø¨ Ø°ÙƒÙŠØ© | ğŸ—ï¸ Ø¨Ù†Ø§Ø¡ ÙˆØªØ¯Ù…ÙŠØ±</p>
        <p style="margin-top:12px; font-size:14px; color:#aaa;">
            <strong>Ø§Ù„ØªØ­ÙƒÙ…:</strong> WASD - Ø­Ø±ÙƒØ© | Ù…Ø³Ø§ÙØ© - Ù‚ÙØ² | F - Ø·ÙŠØ±Ø§Ù†<br>
            Ù…Ø§ÙˆØ³: Ø§Ø¶ØºØ· Ù…Ø·ÙˆÙ„Ø§Ù‹ - ØªÙƒØ³ÙŠØ± | ÙƒÙ„ÙŠÙƒ ÙŠÙ…ÙŠÙ† - Ø¨Ù†Ø§Ø¡<br>
            E - Ø§Ù„ØªÙØ§Ø¹Ù„ | Q - Ù…Ù‡Ø§Ø¬Ù…Ø© | Ø£Ø±Ù‚Ø§Ù… 1-7 - Ø§Ø®ØªÙŠØ§Ø± Ù…ÙƒØ¹Ø¨
        </p>
        <button id="start-btn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ==================== Ø§Ù„Ø£ØµÙˆØ§Øª ====================
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let ambientSound = null;

        function createAmbientSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(120, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            ambientSound = { oscillator, gainNode };
        }

        // ==================== Ù…ÙˆÙ„Ø¯ Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡ ====================
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                for(let i=0; i<256; i++) this.p[i] = i;
                const random = this.seededRandom(seed);
                for(let i=0; i<256; i++) {
                    const r = Math.floor(random() * 256);
                    [this.p[i], this.p[r]] = [this.p[r], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for(let i=0; i<512; i++) this.perm[i] = this.p[i & 255];
            }
            seededRandom(seed) {
                let x = Math.sin(seed++) * 10000;
                return () => { x = Math.sin(x) * 10000; return x - Math.floor(x); };
            }
            noise2D(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = x*x*x*(x*(x*6-15)+10), v = y*y*y*(y*(y*6-15)+10);
                const A = this.perm[X]+Y, B = this.perm[X+1]+Y;
                return this.lerp(v, this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x-1, y)),
                                    this.lerp(u, this.grad(this.perm[A+1], x, y-1), this.grad(this.perm[B+1], x-1, y-1)));
            }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h<8 ? x : y, v = h<4 ? y : (h===12||h===14 ? x : 0);
                return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);
            }
        }

        // ==================== Ø«ÙˆØ§Ø¨Øª Ø§Ù„Ù„Ø¹Ø¨Ø© ====================
        const CHUNK_SIZE = 16;
        const CITY_SIZE = 10;
        const WALL_HEIGHT = 15;
        const WALL_THICKNESS = 2;
        const GRAVITY = 25.0;
        const JUMP_FORCE = 10.0;
        const SPEED_WALK = 5.5;
        const SPEED_FLY = 14.0;
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_RADIUS = 0.3;
        const DAY_CYCLE_DURATION = 300;
        const BREAK_TIME = 1.5; // Ø«Ø§Ù†ÙŠØ© Ù„ÙƒØ³Ø± Ø§Ù„Ù…ÙƒØ¹Ø¨

        const NOISE = new SimplexNoise(12345);
        
        const BLOCKS = { 
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, 
            WATER: 6, SAND: 7, PLANK: 8, BRICK: 9, COBBLESTONE: 10,
            DOOR: 11, GLASS: 12, TORCH: 13, BED: 14
        };
        
        const BLOCK_COLORS = { 
            [BLOCKS.GRASS]: '#4a9c2d', [BLOCKS.DIRT]: '#7a5c3d', 
            [BLOCKS.STONE]: '#808080', [BLOCKS.WOOD]: '#6b4423', 
            [BLOCKS.LEAVES]: '#2d5016', [BLOCKS.WATER]: '#2463a8',
            [BLOCKS.SAND]: '#d4c090', [BLOCKS.PLANK]: '#8b6c42', 
            [BLOCKS.BRICK]: '#a04040', [BLOCKS.COBBLESTONE]: '#6b6b6b',
            [BLOCKS.DOOR]: '#5c3a1f', [BLOCKS.GLASS]: '#a8d8ff',
            [BLOCKS.TORCH]: '#ffaa00', [BLOCKS.BED]: '#c04040'
        };

        const MALE_NAMES = ['Ø£Ø­Ù…Ø¯', 'Ù…Ø­Ù…Ø¯', 'Ø¹Ù„ÙŠ', 'Ø­Ø³Ù†', 'Ø®Ø§Ù„Ø¯', 'Ø¹Ù…Ø±', 'Ø³Ø¹ÙŠØ¯', 'Ø·Ø§Ø±Ù‚', 'ÙŠØ§Ø³Ø±', 'ÙÙ‡Ø¯'];
        const FEMALE_NAMES = ['ÙØ§Ø·Ù…Ø©', 'Ø¹Ø§Ø¦Ø´Ø©', 'Ù…Ø±ÙŠÙ…', 'Ø®Ø¯ÙŠØ¬Ø©', 'Ø³Ø§Ø±Ø©', 'Ù†ÙˆØ±', 'Ù„ÙŠÙ†Ø§', 'Ù‡Ù†Ø¯', 'Ø¯ÙŠÙ†Ø§', 'Ø±ÙŠÙ…'];

        // ==================== Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© ====================
        let camera, scene, renderer, controls;
        let world = new Map();
        let meshes = [];
        let raycaster = new THREE.Raycaster();
        
        let player = {
            pos: new THREE.Vector3(),
            vel: new THREE.Vector3(),
            onGround: false,
            flying: false,
            health: 100,
            maxHealth: 100,
            wives: []
        };
        
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false, e:false, q:false };
        let joystickMove = { x: 0, y: 0 };
        let joystickLook = { x: 0, y: 0 };
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let selectedBlock = BLOCKS.BRICK;

        // Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ³Ø± Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ
        let breakingBlock = null;
        let breakProgress = 0;
        let isBreaking = false;

        let gameTime = 0.25;
        let sunLight, moonLight;
        let skyGradient;

        let npcs = [];
        let houses = [];
        let kingHouse = null;
        let beds = [];

        let monsters = [];
        let doors = [];
        let gateBlocks = [];
        let gatesOpen = false;

        // ==================== Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ÙˆÙ„ÙŠ ====================
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xfff5e6, 0.8);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -80;
            sunLight.shadow.camera.right = 80;
            sunLight.shadow.camera.top = 80;
            sunLight.shadow.camera.bottom = -80;
            scene.add(sunLight);

            moonLight = new THREE.DirectionalLight(0x7090ff, 0.2);
            scene.add(moonLight);

            createSky();

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            generateCity();
            
            if (kingHouse) {
                player.pos.set(kingHouse.x + 10, kingHouse.y + 3, kingHouse.z + 10);
            }
            camera.position.copy(player.pos);

            setupControls();
            createHotbar();

            animate();
        }

        // ==================== Ø§Ù„Ø³Ù…Ø§Ø¡ ====================
        function createSky() {
            const skyGeo = new THREE.SphereGeometry(300, 16, 16);
            const skyMat = new THREE.MeshBasicMaterial({ 
                side: THREE.BackSide,
                color: 0x87CEEB
            });
            
            skyGradient = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skyGradient);
        }

        function updateSky() {
            const dayProgress = gameTime % 1;
            let color;
            
            if (dayProgress < 0.25) {
                const t = dayProgress / 0.25;
                color = new THREE.Color().setRGB(0.08 + t * 0.45, 0.08 + t * 0.55, 0.15 + t * 0.70);
            } else if (dayProgress < 0.5) {
                const t = (dayProgress - 0.25) / 0.25;
                color = new THREE.Color().setRGB(0.53 + t * 0.15, 0.63 + t * 0.15, 0.85 + t * 0.10);
            } else if (dayProgress < 0.75) {
                const t = (dayProgress - 0.5) / 0.25;
                color = new THREE.Color().setRGB(0.68 - t * 0.28, 0.78 - t * 0.48, 0.95 - t * 0.60);
            } else {
                const t = (dayProgress - 0.75) / 0.25;
                color = new THREE.Color().setRGB(0.40 - t * 0.32, 0.30 - t * 0.22, 0.35 - t * 0.20);
            }
            
            scene.background = color;
            scene.fog.color.copy(color);
            skyGradient.material.color.copy(color);
            
            const angle = dayProgress * Math.PI * 2;
            sunLight.position.set(Math.cos(angle) * 200, Math.sin(angle) * 200, 100);
            moonLight.position.set(-Math.cos(angle) * 200, -Math.sin(angle) * 200, -100);
            
            if (isNightTime()) {
                sunLight.intensity = 0.2;
                moonLight.intensity = 0.3;
            } else {
                sunLight.intensity = 0.9;
                moonLight.intensity = 0.05;
            }
        }

        function isNightTime() {
            const dayProgress = gameTime % 1;
            return dayProgress < 0.25 || dayProgress > 0.75;
        }

        function isSleepTime() {
            const dayProgress = gameTime % 1;
            return dayProgress < 0.20 || dayProgress > 0.80;
        }

        function getTimeString() {
            const dayProgress = gameTime % 1;
            if (dayProgress < 0.25) return 'ğŸŒ™ Ù„ÙŠÙ„';
            if (dayProgress < 0.40) return 'â˜€ï¸ ØµØ¨Ø§Ø­';
            if (dayProgress < 0.65) return 'ğŸŒ Ø¸Ù‡Ø±';
            if (dayProgress < 0.75) return 'ğŸŒ‡ Ù…Ø³Ø§Ø¡';
            return 'ğŸŒ™ Ù„ÙŠÙ„';
        }

        // ==================== Ø§Ù„Ø®Ø§Ù…Ø§Øª ====================
        function createTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 32; 
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0,0,32,32);
            
            for(let i=0; i<100; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
                ctx.fillRect(Math.random()*32, Math.random()*32, 2, 2);
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            return tex;
        }

        const materials = {};
        for(let key in BLOCK_COLORS) {
            materials[key] = new THREE.MeshLambertMaterial({ 
                map: createTexture(BLOCK_COLORS[key])
            });
        }
        materials[BLOCKS.WATER].transparent = true;
        materials[BLOCKS.WATER].opacity = 0.6;
        materials[BLOCKS.GLASS].transparent = true;
        materials[BLOCKS.GLASS].opacity = 0.4;

        // ==================== ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© ====================
        function generateCity() {
            const centerX = (CITY_SIZE * CHUNK_SIZE) / 2;
            const centerZ = (CITY_SIZE * CHUNK_SIZE) / 2;
            const cityRadius = (CITY_SIZE * CHUNK_SIZE) / 2 - 5;

            for (let x = 0; x < CITY_SIZE * CHUNK_SIZE; x++) {
                for (let z = 0; z < CITY_SIZE * CHUNK_SIZE; z++) {
                    setBlock(x, 0, z, BLOCKS.STONE);
                    setBlock(x, 1, z, BLOCKS.GRASS);
                }
            }

            buildWall(centerX, centerZ, cityRadius);
            buildGate(centerX, 2, centerZ - cityRadius + 3, 'north');
            buildGate(centerX, 2, centerZ + cityRadius - 3, 'south');
            buildGate(centerX - cityRadius + 3, 2, centerZ, 'west');
            buildGate(centerX + cityRadius - 3, 2, centerZ, 'east');
            buildStreets(centerX, centerZ, cityRadius);
            kingHouse = buildKingHouse(centerX - 12, centerZ - 12);
            buildManyHouses(centerX, centerZ, cityRadius);

            updateChunks();
            populateCity();
        }

        function buildWall(cx, cz, radius) {
            for (let angle = 0; angle < 360; angle += 2) {
                const rad = (angle * Math.PI) / 180;
                const x = Math.round(cx + Math.cos(rad) * radius);
                const z = Math.round(cz + Math.sin(rad) * radius);
                
                for (let dx = -WALL_THICKNESS; dx <= WALL_THICKNESS; dx++) {
                    for (let dz = -WALL_THICKNESS; dz <= WALL_THICKNESS; dz++) {
                        for (let y = 2; y < WALL_HEIGHT; y++) {
                            setBlock(x + dx, y, z + dz, BLOCKS.COBBLESTONE);
                        }
                        if ((dx + dz) % 3 === 0) {
                            setBlock(x + dx, WALL_HEIGHT, z + dz, BLOCKS.COBBLESTONE);
                        }
                    }
                }
            }
        }

        function buildGate(x, y, z, direction) {
            const gateWidth = 7;
            const gateHeight = 9;
            
            for (let dx = 0; dx < gateWidth; dx++) {
                for (let dy = 0; dy < gateHeight; dy++) {
                    const bx = direction === 'north' || direction === 'south' ? x - gateWidth/2 + dx : x;
                    const bz = direction === 'west' || direction === 'east' ? z - gateWidth/2 + dx : z;
                    
                    setBlock(bx, y + dy, bz, BLOCKS.DOOR);
                    gateBlocks.push({ x: bx, y: y + dy, z: bz });
                }
            }
        }

        function buildStreets(cx, cz, radius) {
            const streetWidth = 3;
            
            for (let x = cx - radius + 10; x < cx + radius - 10; x++) {
                for (let z = cz - 1; z < cz + 2; z++) {
                    setBlock(x, 2, z, BLOCKS.COBBLESTONE);
                }
            }
            
            for (let z = cz - radius + 10; z < cz + radius - 10; z++) {
                for (let x = cx - 1; x < cx + 2; x++) {
                    setBlock(x, 2, z, BLOCKS.COBBLESTONE);
                }
            }
        }

        function buildKingHouse(bx, bz) {
            const width = 20, depth = 20, height = 10;
            const baseY = 2;
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    setBlock(bx + x, baseY, bz + z, BLOCKS.PLANK);
                }
            }
            
            for (let y = 1; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    setBlock(bx + x, baseY + y, bz, BLOCKS.BRICK);
                    setBlock(bx + x, baseY + y, bz + depth - 1, BLOCKS.BRICK);
                }
                for (let z = 0; z < depth; z++) {
                    setBlock(bx, baseY + y, bz + z, BLOCKS.BRICK);
                    setBlock(bx + width - 1, baseY + y, bz + z, BLOCKS.BRICK);
                }
            }
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    setBlock(bx + x, baseY + height, bz + z, BLOCKS.BRICK);
                }
            }
            
            // Ø§Ù„Ø¨Ø§Ø¨
            const doorX = bx + width/2;
            const doorZ = bz;
            setBlock(doorX, baseY + 1, doorZ, BLOCKS.AIR);
            setBlock(doorX, baseY + 2, doorZ, BLOCKS.AIR);
            setBlock(doorX, baseY + 3, doorZ, BLOCKS.AIR);
            doors.push({ x: doorX, y: baseY + 1, z: doorZ, isOpen: false, house: null });
            
            beds.push({
                x: bx + width/2,
                y: baseY + 1,
                z: bz + depth/2,
                owner: 'Ø§Ù„Ù…Ù„Ùƒ',
                occupied: false
            });
            
            return { x: bx, y: baseY, z: bz, width, depth, height, owner: 'Ø§Ù„Ù…Ù„Ùƒ', children: [], floors: 1 };
        }

        function buildManyHouses(cx, cz, radius) {
            const houseSize = 12;
            const spacing = 16;
            
            for (let gridX = -2; gridX <= 2; gridX++) {
                for (let gridZ = -2; gridZ <= 2; gridZ++) {
                    if (Math.abs(gridX) <= 1 && Math.abs(gridZ) <= 1) continue;
                    
                    const hx = cx + gridX * spacing;
                    const hz = cz + gridZ * spacing;
                    
                    const distFromCenter = Math.sqrt(Math.pow(hx - cx, 2) + Math.pow(hz - cz, 2));
                    if (distFromCenter < radius - 15) {
                        const house = buildHouse(hx, 2, hz, houseSize, houseSize);
                        houses.push(house);
                    }
                }
            }
        }

        function buildHouse(bx, baseY, bz, width, depth) {
            const height = 6;
            const maleName = MALE_NAMES[Math.floor(Math.random() * MALE_NAMES.length)];
            const femaleName = FEMALE_NAMES[Math.floor(Math.random() * FEMALE_NAMES.length)];
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    setBlock(bx + x, baseY, bz + z, BLOCKS.PLANK);
                }
            }
            
            for (let y = 1; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    setBlock(bx + x, baseY + y, bz, BLOCKS.PLANK);
                    setBlock(bx + x, baseY + y, bz + depth - 1, BLOCKS.PLANK);
                }
                for (let z = 0; z < depth; z++) {
                    setBlock(bx, baseY + y, bz + z, BLOCKS.PLANK);
                    setBlock(bx + width - 1, baseY + y, bz + z, BLOCKS.PLANK);
                }
            }
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    setBlock(bx + x, baseY + height, bz + z, BLOCKS.BRICK);
                }
            }
            
            // Ø§Ù„Ø¨Ø§Ø¨
            const doorX = bx + width/2;
            const doorZ = bz;
            
            // Ø³Ù„Ù… Ù„Ù„Ø¨Ø§Ø¨
            setBlock(doorX, baseY - 1, doorZ - 1, BLOCKS.COBBLESTONE);
            setBlock(doorX, baseY, doorZ - 1, BLOCKS.COBBLESTONE);
            
            setBlock(doorX, baseY + 1, doorZ, BLOCKS.AIR);
            setBlock(doorX, baseY + 2, doorZ, BLOCKS.AIR);
            
            const house = { 
                x: bx, y: baseY, z: bz, width, depth, height,
                owner: maleName, spouse: femaleName,
                doorX, doorZ, children: [], floors: 1
            };
            
            doors.push({ x: doorX, y: baseY + 1, z: doorZ, isOpen: false, house: house });
            
            beds.push({
                x: bx + width/2,
                y: baseY + 1,
                z: bz + depth/2,
                owner: maleName,
                spouse: femaleName,
                occupied: false
            });
            
            return house;
        }

        function buildSecondFloor(house) {
            const bx = house.x;
            const bz = house.z;
            const width = house.width;
            const depth = house.depth;
            const newFloorY = house.y + house.height + 1;
            const floorHeight = 5;
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    setBlock(bx + x, newFloorY, bz + z, BLOCKS.PLANK);
                }
            }
            
            for (let y = 1; y < floorHeight; y++) {
                for (let x = 0; x < width; x++) {
                    setBlock(bx + x, newFloorY + y, bz, BLOCKS.PLANK);
                    setBlock(bx + x, newFloorY + y, bz + depth - 1, BLOCKS.PLANK);
                }
                for (let z = 0; z < depth; z++) {
                    setBlock(bx, newFloorY + y, bz + z, BLOCKS.PLANK);
                    setBlock(bx + width - 1, newFloorY + y, bz + z, BLOCKS.PLANK);
                }
            }
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    setBlock(bx + x, newFloorY + floorHeight, bz + z, BLOCKS.BRICK);
                }
            }
            
            house.height += floorHeight + 1;
            house.floors++;
            
            updateChunks();
        }

        // ==================== NPCs - Ù…Ø­Ø³Ù‘Ù† Ù„Ù„Ø£Ø¯Ø§Ø¡ ====================
        function createNPCMesh(gender, name, isChild = false) {
            const group = new THREE.Group();
            const scale = isChild ? 0.6 : 1.0;
            
            const skinColor = gender === 'female' ? 0xffd9c4 : 0xffd1a3;
            const shirtColor = gender === 'female' ? 0xe74c3c : 0x2c3e50;
            
            const matSkin = new THREE.MeshLambertMaterial({color: skinColor});
            const matShirt = new THREE.MeshLambertMaterial({color: shirtColor});
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6 * scale, 0.6 * scale, 0.6 * scale), matSkin);
            head.position.y = 1.7 * scale;
            head.castShadow = true;
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.9 * scale, 0.4 * scale), matShirt);
            body.position.y = 1.0 * scale;
            body.castShadow = true;

            const legGeo = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
            const legL = new THREE.Mesh(legGeo, matSkin);
            legL.position.set(-0.2 * scale, 0.4 * scale, 0);
            legL.castShadow = true;
            
            const legR = new THREE.Mesh(legGeo, matSkin);
            legR.position.set(0.2 * scale, 0.4 * scale, 0);
            legR.castShadow = true;

            group.add(head, body, legL, legR);
            group.userData = { legL, legR, scale };
            return group;
        }

        function populateCity() {
            houses.forEach(house => {
                const maleMesh = createNPCMesh('male', house.owner);
                maleMesh.position.set(house.x + house.width/2, house.y + 2, house.z + house.depth/2);
                scene.add(maleMesh);
                
                const male = {
                    mesh: maleMesh,
                    name: house.owner,
                    gender: 'male',
                    age: 'adult',
                    house: house,
                    spouse: house.spouse,
                    health: 100,
                    maxHealth: 100,
                    alive: true,
                    state: 'idle',
                    sleeping: false,
                    outside: false
                };
                npcs.push(male);
                
                const femaleMesh = createNPCMesh('female', house.spouse);
                femaleMesh.position.set(house.x + house.width/2 + 2, house.y + 2, house.z + house.depth/2);
                scene.add(femaleMesh);
                
                const female = {
                    mesh: femaleMesh,
                    name: house.spouse,
                    gender: 'female',
                    age: 'adult',
                    house: house,
                    spouse: house.owner,
                    health: 100,
                    maxHealth: 100,
                    alive: true,
                    state: 'idle',
                    sleeping: false,
                    outside: false,
                    pregnant: false,
                    pregnancyTime: 0
                };
                npcs.push(female);
            });
        }

        function updateNPCs(dt) {
            const sleepTime = isSleepTime();
            const morning = !isNightTime() && !sleepTime;
            
            npcs.forEach(npc => {
                if (!npc.alive || npc.age !== 'adult') return;
                
                const m = npc.mesh;
                
                // Ù†Ø¸Ø§Ù… Ø§Ù„Ù†ÙˆÙ…
                if (sleepTime && !npc.sleeping) {
                    const bed = beds.find(b => b.owner === npc.name || b.spouse === npc.name);
                    if (bed && !bed.occupied) {
                        npc.sleeping = true;
                        npc.outside = false;
                        m.position.set(bed.x, bed.y + 0.2, bed.z);
                        m.rotation.z = Math.PI / 2;
                        bed.occupied = true;
                        
                        // Ø¹Ù„Ø§Ù‚Ø© Ø²ÙˆØ¬ÙŠØ©
                        if (npc.gender === 'female' && npc.spouse && Math.random() < 0.2 && !npc.pregnant) {
                            const husband = npcs.find(n => n.name === npc.spouse && n.alive && n.sleeping);
                            if (husband) {
                                npc.pregnant = true;
                                npc.pregnancyTime = 0;
                            }
                        }
                    }
                } else if (morning && npc.sleeping) {
                    // Ø§Ù„Ø§Ø³ØªÙŠÙ‚Ø§Ø¸ ÙˆØ§Ù„Ø®Ø±ÙˆØ¬
                    npc.sleeping = false;
                    m.rotation.z = 0;
                    
                    const house = npc.house;
                    m.position.set(house.doorX, house.y + 2, house.doorZ - 3);
                    npc.outside = true;
                    
                    const bed = beds.find(b => b.x === Math.floor(m.position.x) && b.z === Math.floor(m.position.z));
                    if (bed) bed.occupied = false;
                } else if (isNightTime() && npc.outside && !npc.sleeping) {
                    // Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨ÙŠØª
                    const house = npc.house;
                    m.position.set(house.x + house.width/2, house.y + 2, house.z + house.depth/2);
                    npc.outside = false;
                }
                
                // Ø§Ù„Ø­Ù…Ù„ ÙˆØ§Ù„ÙˆÙ„Ø§Ø¯Ø©
                if (npc.pregnant) {
                    npc.pregnancyTime += dt;
                    if (npc.pregnancyTime > 45) {
                        giveBirth(npc);
                        npc.pregnant = false;
                        npc.pregnancyTime = 0;
                    }
                }
                
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¨Ù‚Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¶
                const groundY = npc.house.y + 2;
                if (Math.abs(m.position.y - groundY) > 0.5) {
                    m.position.y = groundY;
                }
            });
        }

        function giveBirth(mother) {
            const house = mother.house;
            const childGender = Math.random() < 0.5 ? 'male' : 'female';
            const childName = childGender === 'male' ? 
                MALE_NAMES[Math.floor(Math.random() * MALE_NAMES.length)] :
                FEMALE_NAMES[Math.floor(Math.random() * FEMALE_NAMES.length)];
            
            buildSecondFloor(house);
            
            const bedY = house.y + house.height - 5;
            beds.push({
                x: house.x + house.width/2,
                y: bedY + 1,
                z: house.z + house.depth/2,
                owner: childName,
                occupied: false
            });
            
            const childMesh = createNPCMesh(childGender, childName, true);
            childMesh.position.set(house.x + house.width/2, bedY + 1, house.z + house.depth/2);
            scene.add(childMesh);
            
            const child = {
                mesh: childMesh,
                name: childName,
                gender: childGender,
                age: 'child',
                house: house,
                health: 100,
                maxHealth: 100,
                alive: true,
                sleeping: false
            };
            npcs.push(child);
            
            house.children.push(childName);
            showNotification(`ğŸ‘¶ ÙˆÙ„Ø¯ Ø·ÙÙ„: ${childName}`);
        }

        function killNPC(npc) {
            npc.alive = false;
            scene.remove(npc.mesh);
        }

        // ==================== Ø§Ù„ÙˆØ­ÙˆØ´ - Ù…Ø­Ø³Ù‘Ù† ====================
        function createMonsterMesh() {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({color: 0x2d5016});
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), mat);
            head.position.y = 1.8;
            head.castShadow = true;
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.0, 0.5), mat);
            body.position.y = 1.1;
            body.castShadow = true;

            const legGeo = new THREE.BoxGeometry(0.3, 0.9, 0.3);
            const legL = new THREE.Mesh(legGeo, mat);
            legL.position.set(-0.2, 0.45, 0);
            legL.castShadow = true;
            
            const legR = new THREE.Mesh(legGeo, mat);
            legR.position.set(0.2, 0.45, 0);
            legR.castShadow = true;

            group.add(head, body, legL, legR);
            group.userData = { legL, legR };
            return group;
        }

        function spawnMonsterAtGate() {
            if (gateBlocks.length === 0 || monsters.length > 15) return;
            
            const gate = gateBlocks[Math.floor(Math.random() * gateBlocks.length)];
            const monster = createMonsterMesh();
            monster.position.set(gate.x, gate.y + 1, gate.z);
            scene.add(monster);
            monsters.push({ 
                mesh: monster, 
                velY: 0, 
                active: true, 
                health: 50,
                burning: false
            });
        }

        function updateMonsters(dt) {
            if (gatesOpen && Math.random() < 0.01) {
                spawnMonsterAtGate();
            }
            
            const toRemove = [];
            
            monsters.forEach((mob, idx) => {
                if(!mob.active) {
                    toRemove.push(idx);
                    return;
                }
                
                const m = mob.mesh;
                
                if (!isNightTime() && !mob.burning) {
                    mob.burning = true;
                }
                
                if (mob.burning) {
                    mob.health -= dt * 20;
                    if (mob.health <= 0) {
                        scene.remove(m);
                        mob.active = false;
                        toRemove.push(idx);
                        return;
                    }
                }
                
                // Ø¬Ø§Ø°Ø¨ÙŠØ©
                mob.velY -= GRAVITY * dt;
                m.position.y += mob.velY * dt;

                const by = Math.floor(m.position.y - 1);
                if(isSolid(Math.floor(m.position.x), by, Math.floor(m.position.z))) {
                    m.position.y = by + 2;
                    mob.velY = 0;
                }

                // Ù…Ø·Ø§Ø±Ø¯Ø© Ø¨Ø³ÙŠØ·Ø©
                const dist = m.position.distanceTo(player.pos);
                if(dist > 2 && dist < 40 && !mob.burning) {
                    const dx = player.pos.x - m.position.x;
                    const dz = player.pos.z - m.position.z;
                    const d = Math.sqrt(dx*dx + dz*dz);
                    
                    const speed = 2.0 * dt;
                    m.position.x += (dx/d) * speed;
                    m.position.z += (dz/d) * speed;
                    
                    if (dist < 2) {
                        player.health -= dt * 8;
                        updateHealthBar();
                        if (player.health <= 0) {
                            respawnPlayer();
                        }
                    }
                }
            });
            
            // ØªÙ†Ø¸ÙŠÙ
            for (let i = toRemove.length - 1; i >= 0; i--) {
                monsters.splice(toRemove[i], 1);
            }
        }

        function respawnPlayer() {
            player.health = player.maxHealth;
            player.vel.set(0, 0, 0);
            if (kingHouse) {
                player.pos.set(kingHouse.x + 10, kingHouse.y + 5, kingHouse.z + 10);
            }
            updateHealthBar();
            showNotification('Ø¹Ø¯Øª Ø¥Ù„Ù‰ Ù‚ØµØ±Ùƒ');
        }

        // ==================== Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨ ====================
        function updateDoors() {
            doors.forEach(door => {
                const dist = Math.sqrt(
                    Math.pow(player.pos.x - door.x, 2) +
                    Math.pow(player.pos.z - door.z, 2)
                );
                
                // Ø¯Ø®ÙˆÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨
                if (dist < 3) {
                    if (!door.isOpen) {
                        setBlock(door.x, door.y, door.z, BLOCKS.AIR);
                        setBlock(door.x, door.y + 1, door.z, BLOCKS.AIR);
                        door.isOpen = true;
                    }
                    
                    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØµØ§Ø¯Ù… Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø§Ø¨
                    if (dist < 1.5) {
                        const dx = Math.abs(player.pos.x - door.x);
                        const dz = Math.abs(player.pos.z - door.z);
                        if (dx < 0.8 && dz < 0.8) {
                            // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ù…Ø±ÙˆØ±
                        }
                    }
                } else if (dist >= 3 && door.isOpen) {
                    setBlock(door.x, door.y, door.z, BLOCKS.DOOR);
                    setBlock(door.x, door.y + 1, door.z, BLOCKS.DOOR);
                    door.isOpen = false;
                }
            });
            
            // Ø¨ÙˆØ§Ø¨Ø§Øª Ø§Ù„Ø³ÙˆØ±
            const shouldOpen = isNightTime();
            if (shouldOpen !== gatesOpen) {
                gateBlocks.forEach(gate => {
                    setBlock(gate.x, gate.y, gate.z, shouldOpen ? BLOCKS.AIR : BLOCKS.DOOR);
                });
                gatesOpen = shouldOpen;
                
                if (gatesOpen) {
                    showNotification('ğŸŒ™ ÙÙØªØ­Øª Ø§Ù„Ø¨ÙˆØ§Ø¨Ø§Øª - Ø§Ø­Ø°Ø±!');
                } else {
                    showNotification('â˜€ï¸ Ø£ÙØºÙ„Ù‚Øª Ø§Ù„Ø¨ÙˆØ§Ø¨Ø§Øª');
                }
            }
        }

        // ==================== Ø§Ù„Ø¹Ø§Ù„Ù… ====================
        function getBlock(x, y, z) {
            return world.get(`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`) || BLOCKS.AIR;
        }

        function setBlock(x, y, z, id) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if(id === BLOCKS.AIR) world.delete(key);
            else world.set(key, id);
        }

        function isSolid(x, y, z) {
            const b = getBlock(x, y, z);
            // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ø¨Ø± Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨ Ø§Ù„Ù…ÙØªÙˆØ­Ø©
            if (b === BLOCKS.DOOR) {
                const door = doors.find(d => d.x === x && (d.y === y || d.y + 1 === y) && d.z === z);
                if (door && door.isOpen) return false;
            }
            return b !== BLOCKS.AIR && b !== BLOCKS.WATER && b !== BLOCKS.GLASS;
        }

        function updateChunks() {
            meshes.forEach(m => {
                scene.remove(m);
                if (m.geometry) m.geometry.dispose();
                if (m.material) {
                    if (Array.isArray(m.material)) {
                        m.material.forEach(mat => mat.dispose());
                    } else {
                        m.material.dispose();
                    }
                }
            });
            meshes = [];

            const geometryGroups = {};

            for (const [key, val] of world) {
                if (!geometryGroups[val]) geometryGroups[val] = [];
                const [x, y, z] = key.split(',').map(Number);
                
                if (isSolid(x+1,y,z) && isSolid(x-1,y,z) && isSolid(x,y+1,z) && 
                    isSolid(x,y-1,z) && isSolid(x,y,z+1) && isSolid(x,y,z-1)) continue;

                const matrix = new THREE.Matrix4().makeTranslation(x, y, z);
                geometryGroups[val].push(matrix);
            }

            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            for (const [type, matrices] of Object.entries(geometryGroups)) {
                if (matrices.length === 0) continue;
                const mesh = new THREE.InstancedMesh(boxGeo, materials[type], matrices.length);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                for (let i = 0; i < matrices.length; i++) mesh.setMatrixAt(i, matrices[i]);
                
                mesh.blockType = parseInt(type);
                scene.add(mesh);
                meshes.push(mesh);
            }
        }

        // ==================== Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ ====================
        function setupControls() {
            controls = new PointerLockControls(camera, document.body);
            
            document.getElementById('start-btn').addEventListener('click', () => {
                document.getElementById('overlay').style.display = 'none';
                if(!isMobile) controls.lock();
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        createAmbientSound();
                    });
                }
            });

            if(!isMobile) {
                document.addEventListener('keydown', (e) => onKey(e, true));
                document.addEventListener('keyup', (e) => onKey(e, false));
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mouseup', onMouseUp);
                
                // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
                for (let i = 1; i <= 7; i++) {
                    document.addEventListener('keydown', (e) => {
                        if (e.code === `Digit${i}`) {
                            selectSlot(i - 1);
                        }
                    });
                }
            } else {
                setupMobileTouch();
            }
        }

        function onKey(e, down) {
            switch(e.code) {
                case 'KeyW': keys.w = down; break;
                case 'KeyS': keys.s = down; break;
                case 'KeyA': keys.a = down; break;
                case 'KeyD': keys.d = down; break;
                case 'Space': keys.space = down; break;
                case 'ShiftLeft': keys.shift = down; break;
                case 'KeyE': if(down) interactWithNPC(); break;
                case 'KeyQ': if(down) attackNPC(); break;
                case 'KeyF': if(down) { player.flying = !player.flying; player.vel.y = 0; } break;
            }
        }

        function onMouseDown(e) {
            if(!controls.isLocked) return;
            if (e.button === 0) {
                isBreaking = true;
                startBreaking();
            } else if (e.button === 2) {
                handleBuild();
            }
        }

        function onMouseUp(e) {
            if (e.button === 0) {
                isBreaking = false;
                breakProgress = 0;
                breakingBlock = null;
                document.getElementById('break-progress').style.display = 'none';
            }
        }

        // Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ³Ø± Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ
        function startBreaking() {
            if (!isBreaking) return;
            
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const matrix = new THREE.Matrix4();
                intersect.object.getMatrixAt(intersect.instanceId, matrix);
                const pos = new THREE.Vector3().setFromMatrixPosition(matrix);
                
                const blockKey = `${pos.x},${pos.y},${pos.z}`;
                
                if (!breakingBlock || breakingBlock !== blockKey) {
                    breakingBlock = blockKey;
                    breakProgress = 0;
                }
                
                document.getElementById('break-progress').style.display = 'block';
            }
        }

        function updateBreaking(dt) {
            if (isBreaking && breakingBlock) {
                breakProgress += dt / BREAK_TIME * 100;
                document.getElementById('break-fill').style.width = breakProgress + '%';
                
                if (breakProgress >= 100) {
                    // ÙƒØ³Ø± Ø§Ù„Ù…ÙƒØ¹Ø¨
                    const [x, y, z] = breakingBlock.split(',').map(Number);
                    setBlock(x, y, z, BLOCKS.AIR);
                    updateChunks();
                    
                    breakProgress = 0;
                    breakingBlock = null;
                    document.getElementById('break-progress').style.display = 'none';
                }
            }
        }

        function handleBuild() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            
            const npcMeshes = npcs.filter(n => n.alive).map(n => n.mesh);
            const npcIntersects = raycaster.intersectObjects(npcMeshes, true);
            
            if (npcIntersects.length > 0) {
                const clickedMesh = npcIntersects[0].object;
                let clickedNPC = npcs.find(n => n.mesh === clickedMesh.parent || n.mesh.children.includes(clickedMesh));
                if (clickedNPC && clickedNPC.alive) {
                    showNPCInfo(clickedNPC);
                    return;
                }
            }

            const intersects = raycaster.intersectObjects(meshes);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const matrix = new THREE.Matrix4();
                intersect.object.getMatrixAt(intersect.instanceId, matrix);
                const pos = new THREE.Vector3().setFromMatrixPosition(matrix);
                
                const n = intersect.face.normal;
                const bx = Math.round(pos.x + n.x);
                const by = Math.round(pos.y + n.y);
                const bz = Math.round(pos.z + n.z);
                
                const dx = Math.abs(bx - player.pos.x);
                const dy = Math.abs(by - (player.pos.y - 1));
                const dz = Math.abs(bz - player.pos.z);
                
                if(dx < 0.6 && dy < 1.0 && dz < 0.6) return;

                setBlock(bx, by, bz, selectedBlock);
                updateChunks();
            }
        }

        function selectSlot(index) {
            document.querySelectorAll('.slot').forEach((s, i) => {
                s.classList.toggle('active', i === index);
            });
            
            const items = [
                BLOCKS.BRICK, BLOCKS.COBBLESTONE, BLOCKS.PLANK, BLOCKS.GLASS,
                BLOCKS.GRASS, BLOCKS.STONE, BLOCKS.DIRT
            ];
            selectedBlock = items[index];
        }

        function setupMobileTouch() {
            const handleStick = (zoneId, callback) => {
                const zone = document.getElementById(zoneId);
                const stick = zone.querySelector('.stick');
                let startX, startY;
                
                zone.addEventListener('touchstart', (e) => {
                    const touch = e.changedTouches[0];
                    startX = touch.clientX; startY = touch.clientY;
                });
                zone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    let dx = touch.clientX - startX;
                    let dy = touch.clientY - startY;
                    const dist = Math.min(60, Math.sqrt(dx*dx + dy*dy));
                    const angle = Math.atan2(dy, dx);
                    
                    stick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                    callback(Math.cos(angle)*dist/60, Math.sin(angle)*dist/60);
                });
                zone.addEventListener('touchend', () => {
                    stick.style.transform = `translate(-50%, -50%)`;
                    callback(0, 0);
                });
            };

            handleStick('joystick-left', (x, y) => { joystickMove.x = x; joystickMove.y = y; });
            handleStick('joystick-right', (x, y) => { joystickLook.x = x; joystickLook.y = y; });
            
            document.getElementById('jump-btn').addEventListener('touchstart', (e) => { 
                e.preventDefault(); keys.space = true; 
            });
            document.getElementById('jump-btn').addEventListener('touchend', (e) => { 
                e.preventDefault(); keys.space = false; 
            });

            document.getElementById('fly-btn').addEventListener('touchstart', (e) => { 
                e.preventDefault(); player.flying = !player.flying; 
            });

            document.getElementById('attack-btn').addEventListener('touchstart', (e) => { 
                e.preventDefault(); attackNPC(); 
            });
        }

        function updatePhysics(dt) {
            const speed = player.flying ? SPEED_FLY : SPEED_WALK;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            forward.y = 0; forward.normalize();
            right.y = 0; right.normalize();

            let dx = 0, dz = 0;
            if(!isMobile) {
                if(keys.w) dz += 1;
                if(keys.s) dz -= 1;
                if(keys.a) dx -= 1;
                if(keys.d) dx += 1;
            } else {
                dz = -joystickMove.y;
                dx = joystickMove.x;
            }

            if(isMobile && (joystickLook.x !== 0 || joystickLook.y !== 0)) {
                camera.rotation.y -= joystickLook.x * 2.0 * dt;
                camera.rotation.x -= joystickLook.y * 2.0 * dt;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }

            const moveVec = new THREE.Vector3().addScaledVector(forward, dz).addScaledVector(right, dx);
            if(moveVec.length() > 0) moveVec.normalize().multiplyScalar(speed);
            
            player.vel.x = moveVec.x;
            player.vel.z = moveVec.z;

            if(player.flying) {
                player.vel.y = 0;
                if(keys.space) player.vel.y = speed;
                if(keys.shift) player.vel.y = -speed;
            } else {
                player.vel.y -= GRAVITY * dt;
                if(player.onGround && keys.space) {
                    player.vel.y = JUMP_FORCE;
                    player.onGround = false;
                }
            }

            player.pos.x += player.vel.x * dt;
            if(checkCollision(player.pos)) player.pos.x -= player.vel.x * dt;

            player.pos.z += player.vel.z * dt;
            if(checkCollision(player.pos)) player.pos.z -= player.vel.z * dt;

            player.pos.y += player.vel.y * dt;
            player.onGround = false;
            
            if(checkCollision(player.pos)) {
                if(player.vel.y < 0) {
                    player.onGround = true;
                    const groundY = Math.ceil(player.pos.y - PLAYER_HEIGHT);
                    player.pos.y = groundY + PLAYER_HEIGHT;
                } else if (player.vel.y > 0) {
                    player.pos.y = Math.floor(player.pos.y + 0.2) - 0.2;
                }
                player.vel.y = 0;
            }

            camera.position.copy(player.pos);
            
            if(player.pos.y < -30) respawnPlayer();
        }

        function checkCollision(pos) {
            const r = PLAYER_RADIUS;
            const points = [
                new THREE.Vector3(pos.x, pos.y - PLAYER_HEIGHT + 0.1, pos.z),
                new THREE.Vector3(pos.x, pos.y - 0.1, pos.z),
                new THREE.Vector3(pos.x + r, pos.y - 1, pos.z),
                new THREE.Vector3(pos.x - r, pos.y - 1, pos.z),
                new THREE.Vector3(pos.x, pos.y - 1, pos.z + r),
                new THREE.Vector3(pos.x, pos.y - 1, pos.z - r)
            ];

            for (let p of points) {
                if (isSolid(Math.floor(p.x), Math.floor(p.y), Math.floor(p.z))) return true;
            }
            return false;
        }

        // ==================== Ø§Ù„ØªÙØ§Ø¹Ù„ ====================
        function interactWithNPC() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const npcMeshes = npcs.filter(n => n.alive).map(n => n.mesh);
            const intersects = raycaster.intersectObjects(npcMeshes, true);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                let clickedNPC = npcs.find(n => n.mesh === clickedMesh.parent || n.mesh.children.includes(clickedMesh));
                if (clickedNPC && clickedNPC.alive) {
                    showNPCInfo(clickedNPC);
                }
            }
        }

        function attackNPC() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const npcMeshes = npcs.filter(n => n.alive).map(n => n.mesh);
            const intersects = raycaster.intersectObjects(npcMeshes, true);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                let clickedNPC = npcs.find(n => n.mesh === clickedMesh.parent || n.mesh.children.includes(clickedMesh));
                if (clickedNPC && clickedNPC.alive) {
                    clickedNPC.health -= 50;
                    if (clickedNPC.health <= 0) {
                        killNPC(clickedNPC);
                        showNotification(`Ù‚ØªÙ„Øª ${clickedNPC.name}`);
                    }
                }
            }
            
            const monsterMeshes = monsters.filter(m => m.active).map(m => m.mesh);
            const monsterIntersects = raycaster.intersectObjects(monsterMeshes, true);
            
            if (monsterIntersects.length > 0) {
                const clickedMesh = monsterIntersects[0].object;
                let clickedMonster = monsters.find(m => m.mesh === clickedMesh.parent || m.mesh.children.includes(clickedMesh));
                if (clickedMonster && clickedMonster.active) {
                    clickedMonster.health -= 30;
                    if (clickedMonster.health <= 0) {
                        scene.remove(clickedMonster.mesh);
                        clickedMonster.active = false;
                    }
                }
            }
        }

        function showNPCInfo(npc) {
            document.getElementById('npc-name').innerText = npc.name;
            document.getElementById('npc-gender').innerText = npc.gender === 'male' ? 'ğŸ‘¨ Ø°ÙƒØ±' : 'ğŸ‘© Ø£Ù†Ø«Ù‰';
            document.getElementById('npc-status').innerText = npc.alive ? 'âœ… Ø­ÙŠ' : 'â˜ ï¸ Ù…ÙŠØª';
            document.getElementById('npc-spouse').innerText = npc.spouse || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯';
            document.getElementById('npc-health').innerText = `${npc.health} / ${npc.maxHealth}`;
            
            const marryBtn = document.getElementById('marry-btn');
            if (npc.gender === 'female' && !npc.spouse && npc.age === 'adult') {
                marryBtn.style.display = 'block';
                marryBtn.onclick = () => {
                    player.wives.push(npc.name);
                    npc.spouse = 'Ø§Ù„Ù…Ù„Ùƒ';
                    updateWivesCount();
                    showNotification(`ØªØ²ÙˆØ¬Øª ${npc.name}`);
                    document.getElementById('npc-info-modal').style.display = 'none';
                };
            } else {
                marryBtn.style.display = 'none';
            }
            
            document.getElementById('attack-npc-btn').onclick = () => {
                attackNPC();
                document.getElementById('npc-info-modal').style.display = 'none';
            };
            
            document.getElementById('npc-info-modal').style.display = 'block';
        }

        document.getElementById('close-modal-btn').addEventListener('click', () => {
            document.getElementById('npc-info-modal').style.display = 'none';
        });

        function showNotification(message) {
            const notif = document.getElementById('notification');
            notif.innerText = message;
            notif.style.display = 'block';
            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }

        function updateHealthBar() {
            const percent = Math.max(0, (player.health / player.maxHealth) * 100);
            document.getElementById('health-fill').style.width = percent + '%';
            document.getElementById('health-text').innerText = `â¤ï¸ ${Math.max(0, Math.round(player.health))} / ${player.maxHealth}`;
        }

        function updateWivesCount() {
            document.getElementById('wives-count').innerText = player.wives.length;
        }

        function createHotbar() {
            const container = document.getElementById('hotbar-container');
            const items = [
                {id: BLOCKS.BRICK, name: 'Ø·ÙˆØ¨'}, {id: BLOCKS.COBBLESTONE, name: 'Ø­Ø¬Ø±'},
                {id: BLOCKS.PLANK, name: 'Ø®Ø´Ø¨'}, {id: BLOCKS.GLASS, name: 'Ø²Ø¬Ø§Ø¬'},
                {id: BLOCKS.GRASS, name: 'Ø¹Ø´Ø¨'}, {id: BLOCKS.STONE, name: 'Ø­Ø¬Ø±'},
                {id: BLOCKS.DIRT, name: 'ØªØ±Ø§Ø¨'}
            ];

            items.forEach((item, i) => {
                const el = document.createElement('div');
                el.className = 'slot' + (i===0?' active':'');
                el.style.backgroundColor = BLOCK_COLORS[item.id];
                el.innerHTML = `<span>${i+1}</span>`;
                el.onclick = () => selectSlot(i);
                container.appendChild(el);
            });
        }

        // ==================== Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© - Ù…Ø­Ø³Ù‘Ù†Ø© ====================
        const clock = new THREE.Clock();
        let lastNPCUpdate = 0;
        let lastMonsterUpdate = 0;
        let lastDoorUpdate = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.05);
            const time = clock.getElapsedTime();

            gameTime += dt / DAY_CYCLE_DURATION;
            
            // ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¨ØµØ±ÙŠØ© ÙƒÙ„ frame
            updateSky();
            updatePhysics(dt);
            updateBreaking(dt);
            
            // ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ù‚Ù„ ØªÙƒØ±Ø§Ø±Ø§Ù‹
            if (time - lastNPCUpdate > 0.2) {
                updateNPCs(dt * 5);
                lastNPCUpdate = time;
            }
            
            if (time - lastMonsterUpdate > 0.15) {
                updateMonsters(dt * 5);
                lastMonsterUpdate = time;
            }
            
            if (time - lastDoorUpdate > 0.5) {
                updateDoors();
                lastDoorUpdate = time;
            }
            
            document.getElementById('time-display').innerText = getTimeString();

            renderer.render(scene, camera);
        }

        init();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
