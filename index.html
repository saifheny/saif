<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù„ÙƒÙŠØ© - Royal City</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            user-select: none; -webkit-user-select: none; 
        }
        
        #canvas-container { width: 100vw; height: 100vh; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØµÙˆÙŠØ¨ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 2px;
            mix-blend-mode: difference;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.8);
        }
        #crosshair::before { 
            width: 2px; height: 8px; left: 50%; top: 50%; 
            transform: translate(-50%, -50%); 
        }
        #crosshair::after { 
            width: 8px; height: 2px; left: 50%; top: 50%; 
            transform: translate(-50%, -50%); 
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª */
        #hotbar-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px; border-radius: 8px; display: flex; gap: 6px; 
            pointer-events: auto; border: 2px solid rgba(255,255,255,0.3);
        }
        .slot {
            width: 50px; height: 50px; border: 2px solid #555; 
            background-size: cover; cursor: pointer; transition: all 0.15s;
            position: relative; border-radius: 4px; background-color: #333;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
        }
        .slot.active { 
            border-color: #fff; transform: scale(1.1); box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .slot:hover:not(.active) { 
            border-color: #888;
        }
        .slot span {
            position: absolute; bottom: 2px; right: 4px; color: #fff; 
            font-size: 10px; font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª */
        #info-panel {
            position: absolute; top: 15px; right: 15px; 
            color: white; text-align: right; font-size: 14px; font-weight: 500;
            background: rgba(0,0,0,0.6);
            padding: 12px 16px; border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
        }
        #info-panel div { 
            margin: 4px 0; 
            text-shadow: 1px 1px 2px #000;
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø© */
        #health-bar {
            position: absolute; bottom: 85px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 24px; background: rgba(0,0,0,0.7);
            border: 2px solid #333; border-radius: 4px; overflow: hidden;
        }
        #health-fill {
            height: 100%; background: linear-gradient(90deg, #c43a3a, #ff5555);
            transition: width 0.3s; width: 100%;
        }
        #health-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 14px;
            text-shadow: 1px 1px 2px #000;
        }

        /* Ù…Ø¤Ø´Ø± Ø§Ù„ÙƒØ³Ø± */
        #break-progress {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, calc(-50% + 40px));
            width: 200px; height: 8px; background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 4px;
            overflow: hidden; display: none;
        }
        #break-fill {
            height: 100%; background: #fff; width: 0%;
            transition: width 0.05s linear;
        }

        /* Ù†Ø§ÙØ°Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© */
        #npc-info-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.95);
            padding: 25px; border-radius: 8px; display: none;
            border: 2px solid rgba(255,255,255,0.3); pointer-events: auto;
            min-width: 300px; max-width: 400px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8);
        }
        #npc-info-modal h2 {
            color: #fff; margin-bottom: 20px; text-align: center;
            font-size: 20px; text-shadow: 1px 1px 2px #000; border-bottom: 1px solid #444; padding-bottom: 10px;
        }
        #npc-info-modal .info-row {
            margin: 10px 0; font-size: 15px; color: white;
            display: flex; justify-content: space-between;
            padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;
        }
        #npc-info-modal .label { color: #aaa; font-weight: 500; }
        #npc-info-modal .close-btn {
            margin-top: 15px; padding: 10px 0; background: #444;
            color: white; border: none; border-radius: 4px; cursor: pointer;
            font-size: 14px; font-weight: bold; width: 100%;
            transition: all 0.2s;
        }
        #npc-info-modal .close-btn:hover { background: #555; }
        #npc-info-modal .action-btn {
            margin-top: 8px; padding: 10px 0; background: #2e7d32;
            color: #fff; border: none; border-radius: 4px; cursor: pointer;
            font-size: 14px; font-weight: bold; width: 100%;
            transition: all 0.2s;
        }
        #npc-info-modal .action-btn:hover { background: #388e3c; }
        #npc-info-modal .attack-btn {
            margin-top: 8px; padding: 10px 0; background: #c62828;
            color: #fff; border: none; border-radius: 4px; cursor: pointer;
            font-size: 14px; font-weight: bold; width: 100%;
            transition: all 0.2s;
        }
        #npc-info-modal .attack-btn:hover { background: #d32f2f; }

        /* Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.95)), url('https://images.unsplash.com/photo-1605806616949-1e87b487bc2a?q=80&w=1000&auto=format&fit=crop');
            background-size: cover; background-position: center;
            display: flex; flex-direction: column; justify-content: center; 
            align-items: center; color: white; pointer-events: auto; z-index: 100;
        }
        #overlay h1 {
            color: #fff; font-size: 48px; margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255,215,0,0.5); letter-spacing: 1px;
        }
        #overlay p {
            font-size: 16px; margin: 6px 0; text-align: center;
            max-width: 600px; line-height: 1.6; color: #ddd;
        }
        #start-btn {
            padding: 15px 60px; font-size: 22px; cursor: pointer; 
            background: #2196f3;
            color: #fff; border: none; border-radius: 50px; margin-top: 30px;
            transition: all 0.3s; font-weight: bold;
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }
        #start-btn:hover { background: #1e88e5; transform: translateY(-2px); box-shadow: 0 8px 20px rgba(33, 150, 243, 0.6); }
        #start-btn:active { transform: scale(0.98); }

        /* Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ */
        #notification {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #fff; padding: 12px 25px;
            border-radius: 30px; font-size: 15px; font-weight: 500;
            border: 1px solid rgba(255,255,255,0.1); display: none; pointer-events: none;
            text-align: center; max-width: 90%;
            animation: fadeInOut 3s forwards;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        /* Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ */
        .joystick-zone {
            position: absolute; bottom: 50px; width: 120px; height: 120px;
            background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(255,255,255,0.02));
            border-radius: 50%; pointer-events: auto; display: none;
            border: 2px solid rgba(255,255,255,0.1);
        }
        #joystick-left { left: 30px; }
        #joystick-right { right: 30px; }
        .stick {
            width: 50px; height: 50px; 
            background: rgba(255,255,255,0.3);
            border-radius: 50%; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        #jump-btn, #fly-btn, #attack-btn {
            position: absolute; width: 60px; height: 60px;
            background: rgba(255,255,255,0.2); border-radius: 50%; color: white;
            display: none; justify-content: center; align-items: center; 
            pointer-events: auto; font-size: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
        }
        #jump-btn { bottom: 180px; right: 40px; }
        #fly-btn { bottom: 180px; left: 40px; }
        #attack-btn { bottom: 100px; right: 120px; background: rgba(255, 50, 50, 0.3); }

        @media (hover: none) and (pointer: coarse) {
            .joystick-zone, #jump-btn, #fly-btn, #attack-btn { display: flex; }
            #info-panel { font-size: 12px; padding: 10px; top: 10px; right: 10px; }
            #hotbar-container { bottom: 10px; transform: translateX(-50%) scale(0.9); }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="game-ui">
        <div id="crosshair"></div>
        
        <div id="info-panel">
            <div>â° <span id="time-display">ØµØ¨Ø§Ø­</span></div>
            <div>ğŸ’‘ Ø²ÙˆØ¬Ø§Øª: <span id="wives-count">0</span></div>
        </div>

        <div id="health-bar">
            <div id="health-fill"></div>
            <div id="health-text">â¤ï¸ 100 / 100</div>
        </div>

        <div id="break-progress">
            <div id="break-fill"></div>
        </div>
        
        <div id="hotbar-container"></div>

        <div id="joystick-left" class="joystick-zone"><div class="stick"></div></div>
        <div id="joystick-right" class="joystick-zone"><div class="stick"></div></div>
        <div id="jump-btn">â¬†ï¸</div>
        <div id="fly-btn">ğŸ¦…</div>
        <div id="attack-btn">âš”ï¸</div>

        <div id="notification"></div>

        <div id="npc-info-modal">
            <h2 id="npc-modal-title">Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©</h2>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø§Ø³Ù…:</span>
                <span id="npc-name"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø¬Ù†Ø³:</span>
                <span id="npc-gender"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø­Ø§Ù„Ø©:</span>
                <span id="npc-status"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„Ø²ÙˆØ¬/Ø©:</span>
                <span id="npc-spouse"></span>
            </div>
            <div class="info-row">
                <span class="label">Ø§Ù„ØµØ­Ø©:</span>
                <span id="npc-health"></span>
            </div>
            <button class="action-btn" id="marry-btn" style="display:none;">ğŸ’‘ Ø·Ù„Ø¨ Ø²ÙˆØ§Ø¬</button>
            <button class="attack-btn" id="attack-npc-btn">âš”ï¸ Ù…Ù‡Ø§Ø¬Ù…Ø©</button>
            <button class="close-btn" id="close-modal-btn">Ø¥ØºÙ„Ø§Ù‚</button>
        </div>
    </div>

    <div id="overlay">
        <h1>ğŸ° Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ù…Ù„ÙƒÙŠØ©</h1>
        <p><strong>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…Ù…Ù„ÙƒØªÙƒ Ø§Ù„Ø®Ø§ØµØ©!</strong></p>
        <p>Ø§Ø³ØªÙ…ØªØ¹ Ø¨ØªØ¬Ø±Ø¨Ø© Ø¨Ù†Ø§Ø¡ ÙˆØ¥Ø¯Ø§Ø±Ø© Ù…Ø¯ÙŠÙ†ØªÙƒ ÙÙŠ Ø¹Ø§Ù„Ù… Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯.</p>
        <p>ğŸŒ™ Ø¯ÙˆØ±Ø© ÙŠÙˆÙ… ÙˆÙ„ÙŠÙ„ ÙˆØ§Ù‚Ø¹ÙŠØ© | ğŸ‘¥ Ø³ÙƒØ§Ù† Ø£Ø°ÙƒÙŠØ§Ø¡ ÙŠØªÙØ§Ø¹Ù„ÙˆÙ† Ù…Ø¹Ùƒ | âš”ï¸ Ø¯Ø§ÙØ¹ Ø¹Ù† Ù…Ø¯ÙŠÙ†ØªÙƒ Ø¶Ø¯ Ø§Ù„ÙˆØ­ÙˆØ´</p>
        
        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-top: 15px; font-size: 14px;">
            <div style="margin-bottom: 5px;">ğŸ® <strong>Ø§Ù„ØªØ­ÙƒÙ… (PC):</strong></div>
            <div>WASD: Ø­Ø±ÙƒØ© | Ù…Ø³Ø§ÙØ©: Ù‚ÙØ² | F: Ø·ÙŠØ±Ø§Ù†</div>
            <div>Ù…Ø§ÙˆØ³: ÙŠØ³Ø§Ø± (ØªÙƒØ³ÙŠØ±) | ÙŠÙ…ÙŠÙ† (Ø¨Ù†Ø§Ø¡) | Ø£Ø±Ù‚Ø§Ù… 1-7 (Ø£Ø¯ÙˆØ§Øª)</div>
            <div>E: ØªÙØ§Ø¹Ù„ | Q: Ù‡Ø¬ÙˆÙ…</div>
        </div>
        
        <button id="start-btn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ==================== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØª ====================
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let ambientSound = null;

        function createAmbientSound() {
            // ØµÙˆØª Ø®Ù„ÙÙŠØ© Ù‡Ø§Ø¯Ø¦ Ø¬Ø¯Ø§Ù‹ (wind/hum)
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.01, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            ambientSound = { oscillator, gainNode };
        }

        // ==================== Ø§Ù„Ø«ÙˆØ§Ø¨Øª ÙˆØ§Ù„Ù…ØªØºÙŠØ±Ø§Øª ====================
        const CHUNK_SIZE = 16;
        const CITY_SIZE = 8; // Ø­Ø¬Ù… Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
        const WALL_HEIGHT = 12;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 12.0;
        const SPEED_WALK = 6.0;
        const SPEED_FLY = 18.0;
        const PLAYER_HEIGHT = 1.7;
        const DAY_CYCLE_DURATION = 240; // Ù…Ø¯Ø© Ø§Ù„ÙŠÙˆÙ… Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
        const BREAK_TIME = 0.8; // Ø³Ø±Ø¹Ø© Ø§Ù„ÙƒØ³Ø±

        const BLOCKS = { 
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, 
            WATER: 6, SAND: 7, PLANK: 8, BRICK: 9, COBBLESTONE: 10,
            DOOR: 11, GLASS: 12, TORCH: 13, BED: 14
        };
        
        const BLOCK_COLORS = { 
            [BLOCKS.GRASS]: '#567d46', [BLOCKS.DIRT]: '#5c4033', 
            [BLOCKS.STONE]: '#7d7d7d', [BLOCKS.WOOD]: '#4a3c31', 
            [BLOCKS.LEAVES]: '#2d4c1e', [BLOCKS.WATER]: '#40a4df',
            [BLOCKS.SAND]: '#e6dbac', [BLOCKS.PLANK]: '#a08362', 
            [BLOCKS.BRICK]: '#b55e55', [BLOCKS.COBBLESTONE]: '#6e6e6e',
            [BLOCKS.DOOR]: '#634734', [BLOCKS.GLASS]: '#a8d8ff',
            [BLOCKS.TORCH]: '#ffaa00', [BLOCKS.BED]: '#c94c4c'
        };

        const MALE_NAMES = ['Ø£Ø­Ù…Ø¯', 'Ù…Ø­Ù…Ø¯', 'Ø¹Ù„ÙŠ', 'Ø­Ø³Ù†', 'Ø®Ø§Ù„Ø¯', 'Ø¹Ù…Ø±', 'Ø³Ø¹ÙŠØ¯', 'Ø·Ø§Ø±Ù‚', 'ÙŠØ§Ø³Ø±', 'ÙÙ‡Ø¯', 'Ø²ÙŠØ§Ø¯'];
        const FEMALE_NAMES = ['ÙØ§Ø·Ù…Ø©', 'Ø¹Ø§Ø¦Ø´Ø©', 'Ù…Ø±ÙŠÙ…', 'Ø®Ø¯ÙŠØ¬Ø©', 'Ø³Ø§Ø±Ø©', 'Ù†ÙˆØ±', 'Ù„ÙŠÙ†Ø§', 'Ù‡Ù†Ø¯', 'Ø¯ÙŠÙ†Ø§', 'Ø±ÙŠÙ…', 'Ø³Ù„Ù…Ù‰'];

        let camera, scene, renderer, controls;
        let world = new Map();
        let meshes = [];
        let raycaster = new THREE.Raycaster();
        
        let player = {
            pos: new THREE.Vector3(),
            vel: new THREE.Vector3(),
            onGround: false,
            flying: false,
            health: 100,
            maxHealth: 100,
            wives: []
        };
        
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false, e:false, q:false };
        let joystickMove = { x: 0, y: 0 };
        let joystickLook = { x: 0, y: 0 };
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let selectedBlock = BLOCKS.BRICK;

        let breakingBlock = null;
        let breakProgress = 0;
        let isBreaking = false;

        let gameTime = 0.3; // Ø§Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ù„ØµØ¨Ø§Ø­
        let sunLight, moonLight, ambientLight;
        let skyGradient;

        let npcs = [];
        let houses = [];
        let kingHouse = null;
        let beds = [];
        let monsters = [];
        let doors = [];
        let gateBlocks = [];
        let gatesOpen = false;

        // ==================== Ø§Ù„ØªÙ‡ÙŠØ¦Ø© (Init) ====================
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 30, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
            
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 300;
            const shadowSize = 80;
            sunLight.shadow.camera.left = -shadowSize;
            sunLight.shadow.camera.right = shadowSize;
            sunLight.shadow.camera.top = shadowSize;
            sunLight.shadow.camera.bottom = -shadowSize;
            scene.add(sunLight);

            moonLight = new THREE.DirectionalLight(0x405080, 0.3);
            scene.add(moonLight);

            createSky();

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            generateCity();
            
            // ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨
            if (kingHouse) {
                player.pos.set(kingHouse.x + 10, kingHouse.y + 4, kingHouse.z + 10);
            } else {
                player.pos.set(0, 10, 0);
            }
            camera.position.copy(player.pos);

            setupControls();
            createHotbar();

            animate();
        }

        // ==================== Ø§Ù„Ø¨ÙŠØ¦Ø© ÙˆØ§Ù„Ø³Ù…Ø§Ø¡ ====================
        function createSky() {
            const skyGeo = new THREE.SphereGeometry(300, 16, 16);
            const skyMat = new THREE.MeshBasicMaterial({ 
                side: THREE.BackSide,
                color: 0x87CEEB
            });
            skyGradient = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skyGradient);
        }

        function updateSky() {
            const dayProgress = gameTime % 1;
            let color;
            
            // ØªØ¯Ø±Ø¬ Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø³Ù…Ø§Ø¡
            if (dayProgress < 0.20) { // Ù„ÙŠÙ„
                const t = dayProgress / 0.20;
                color = new THREE.Color().setRGB(0.02 + t*0.1, 0.02 + t*0.1, 0.1); 
            } else if (dayProgress < 0.30) { // Ø´Ø±ÙˆÙ‚
                const t = (dayProgress - 0.20) / 0.10;
                color = new THREE.Color().lerpColors(new THREE.Color(0x0a0a20), new THREE.Color(0x87CEEB), t);
            } else if (dayProgress < 0.70) { // Ù†Ù‡Ø§Ø±
                color = new THREE.Color(0x87CEEB);
            } else if (dayProgress < 0.80) { // ØºØ±ÙˆØ¨
                const t = (dayProgress - 0.70) / 0.10;
                color = new THREE.Color().lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0x8a3030), t);
            } else { // Ù„ÙŠÙ„
                const t = (dayProgress - 0.80) / 0.20;
                color = new THREE.Color().lerpColors(new THREE.Color(0x8a3030), new THREE.Color(0x02020a), t);
            }
            
            scene.background = color;
            scene.fog.color.copy(color);
            skyGradient.material.color.copy(color);
            
            // Ø­Ø±ÙƒØ© Ø§Ù„Ø´Ù…Ø³ ÙˆØ§Ù„Ù‚Ù…Ø±
            const angle = (dayProgress - 0.25) * Math.PI * 2;
            const radius = 200;
            sunLight.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 50);
            moonLight.position.set(Math.cos(angle + Math.PI) * radius, Math.sin(angle + Math.PI) * radius, 50);
            
            // Ø´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
            if (isNightTime()) {
                sunLight.intensity = 0.05;
                moonLight.intensity = 0.4;
                ambientLight.intensity = 0.2;
            } else {
                sunLight.intensity = 1.0;
                moonLight.intensity = 0.0;
                ambientLight.intensity = 0.6;
            }
        }

        function isNightTime() {
            const p = gameTime % 1;
            return p < 0.25 || p > 0.75;
        }

        function getTimeString() {
            const p = gameTime % 1;
            if (p < 0.25) return 'ğŸŒ™ Ù„ÙŠÙ„';
            if (p < 0.35) return 'ğŸŒ… Ø´Ø±ÙˆÙ‚';
            if (p < 0.65) return 'â˜€ï¸ Ù†Ù‡Ø§Ø±';
            if (p < 0.75) return 'ğŸŒ‡ ØºØ±ÙˆØ¨';
            return 'ğŸŒ™ Ù„ÙŠÙ„';
        }

        // ==================== Ø§Ù„Ù…ÙˆØ§Ø¯ (Textures) ====================
        function createTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Ù„ÙˆÙ† Ø£Ø³Ø§Ø³ÙŠ
            ctx.fillStyle = color;
            ctx.fillRect(0,0,64,64);
            
            // Ø¥Ø¶Ø§ÙØ© Ø¶ÙˆØ¶Ø§Ø¡ Ø¨Ø³ÙŠØ·Ø© Ù„Ù„ØªÙØ§ØµÙŠÙ„
            for(let i=0; i<150; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.08)';
                const s = Math.random() * 4 + 2;
                ctx.fillRect(Math.random()*64, Math.random()*64, s, s);
            }
            
            // Ø¥Ø·Ø§Ø± Ø®ÙÙŠÙ
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 2;
            ctx.strokeRect(0,0,64,64);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            return tex;
        }

        const materials = {};
        for(let key in BLOCK_COLORS) {
            materials[key] = new THREE.MeshLambertMaterial({ 
                map: createTexture(BLOCK_COLORS[key])
            });
        }
        materials[BLOCKS.WATER].transparent = true;
        materials[BLOCKS.WATER].opacity = 0.7;
        materials[BLOCKS.GLASS].transparent = true;
        materials[BLOCKS.GLASS].opacity = 0.4;
        materials[BLOCKS.LEAVES].transparent = true; // Ù„ØªØ­Ø³ÙŠÙ† Ù…Ø¸Ù‡Ø± Ø§Ù„Ø£Ø´Ø¬Ø§Ø±

        // ==================== Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„Ù… ÙˆØ§Ù„Ù…Ø¯ÙŠÙ†Ø© ====================
        function generateCity() {
            const centerX = (CITY_SIZE * CHUNK_SIZE) / 2;
            const centerZ = (CITY_SIZE * CHUNK_SIZE) / 2;
            const cityRadius = (CITY_SIZE * CHUNK_SIZE) / 2 - 8;

            // Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
            for (let x = 0; x < CITY_SIZE * CHUNK_SIZE; x++) {
                for (let z = 0; z < CITY_SIZE * CHUNK_SIZE; z++) {
                    setBlock(x, 0, z, BLOCKS.STONE);
                    setBlock(x, 1, z, BLOCKS.GRASS);
                }
            }

            buildWall(centerX, centerZ, cityRadius);
            
            // Ø¨ÙˆØ§Ø¨Ø§Øª
            buildGate(centerX, 2, centerZ - cityRadius + 2, 'north');
            buildGate(centerX, 2, centerZ + cityRadius - 2, 'south');
            buildGate(centerX - cityRadius + 2, 2, centerZ, 'west');
            buildGate(centerX + cityRadius - 2, 2, centerZ, 'east');
            
            // Ø·Ø±Ù‚
            buildStreets(centerX, centerZ, cityRadius);
            
            // Ù‚ØµØ± Ø§Ù„Ù…Ù„Ùƒ
            kingHouse = buildKingHouse(centerX - 10, centerZ - 10);
            
            // Ù…Ù†Ø§Ø²Ù„ Ø§Ù„Ø³ÙƒØ§Ù†
            buildManyHouses(centerX, centerZ, cityRadius);

            updateChunks();
            populateCity();
        }

        function buildWall(cx, cz, radius) {
            for (let angle = 0; angle < 360; angle += 1.5) { // ÙƒØ«Ø§ÙØ© Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø³ÙˆØ±
                const rad = (angle * Math.PI) / 180;
                const x = Math.round(cx + Math.cos(rad) * radius);
                const z = Math.round(cz + Math.sin(rad) * radius);
                
                // Ø³ÙˆØ± Ø¨Ø³Ù…Ùƒ 3
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        for (let y = 2; y < WALL_HEIGHT; y++) {
                            setBlock(x + dx, y, z + dz, BLOCKS.COBBLESTONE);
                        }
                        // Ø´Ø±ÙØ§Øª Ø§Ù„Ø³ÙˆØ±
                        if (y === WALL_HEIGHT && (dx+dz)%2 === 0) {
                            setBlock(x + dx, WALL_HEIGHT, z + dz, BLOCKS.COBBLESTONE);
                        }
                    }
                }
            }
        }

        function buildGate(x, y, z, dir) {
            // Ù…Ø³Ø­ Ø§Ù„Ø³ÙˆØ± ÙÙŠ Ù…ÙƒØ§Ù† Ø§Ù„Ø¨ÙˆØ§Ø¨Ø©
            const w = 6;
            for(let i=-w/2; i<w/2; i++) {
                for(let h=0; h<8; h++) {
                    const bx = (dir=='north'||dir=='south') ? x+i : x;
                    const bz = (dir=='west'||dir=='east') ? z+i : z;
                    setBlock(bx, y+h, bz, BLOCKS.AIR);
                }
            }
            
            // ÙˆØ¶Ø¹ Ø£Ø¨ÙˆØ§Ø¨ Ø§Ù„Ø¨ÙˆØ§Ø¨Ø©
            for(let i=-w/2+1; i<w/2-1; i++) {
                for(let h=0; h<6; h++) {
                    const bx = (dir=='north'||dir=='south') ? x+i : x;
                    const bz = (dir=='west'||dir=='east') ? z+i : z;
                    setBlock(bx, y+h, bz, BLOCKS.DOOR);
                    gateBlocks.push({x:bx, y:y+h, z:bz});
                }
            }
        }

        function buildStreets(cx, cz, r) {
            // Ø·Ø±ÙŠÙ‚ Ø±Ø¦ÙŠØ³ÙŠ X
            for(let x=cx-r+5; x<cx+r-5; x++) {
                for(let z=cz-2; z<=cz+2; z++) setBlock(x, 1, z, BLOCKS.COBBLESTONE);
            }
            // Ø·Ø±ÙŠÙ‚ Ø±Ø¦ÙŠØ³ÙŠ Z
            for(let z=cz-r+5; z<cz+r-5; z++) {
                for(let x=cx-2; x<=cx+2; x++) setBlock(x, 1, z, BLOCKS.COBBLESTONE);
            }
        }

        function buildKingHouse(bx, bz) {
            const w=20, d=20, h=8;
            // Ø§Ù„Ø£Ø³Ø§Ø³
            for(let x=0; x<w; x++) {
                for(let z=0; z<d; z++) {
                    setBlock(bx+x, 2, bz+z, BLOCKS.PLANK); // Ø£Ø±Ø¶ÙŠØ©
                    // Ø³Ù‚Ù
                    setBlock(bx+x, 2+h, bz+z, BLOCKS.BRICK);
                }
            }
            // Ø¬Ø¯Ø±Ø§Ù†
            for(let y=1; y<h; y++) {
                for(let x=0; x<w; x++) {
                    setBlock(bx+x, 2+y, bz, BLOCKS.BRICK);
                    setBlock(bx+x, 2+y, bz+d-1, BLOCKS.BRICK);
                }
                for(let z=0; z<d; z++) {
                    setBlock(bx, 2+y, bz+z, BLOCKS.BRICK);
                    setBlock(bx+w-1, 2+y, bz+z, BLOCKS.BRICK);
                }
            }
            // Ø¨Ø§Ø¨
            const dx = bx+w/2, dz = bz;
            setBlock(dx, 3, dz, BLOCKS.AIR); setBlock(dx, 4, dz, BLOCKS.AIR);
            doors.push({x:dx, y:3, z:dz, isOpen:false});

            beds.push({x: bx+w/2, y: 3, z: bz+d/2, owner: 'Ø§Ù„Ù…Ù„Ùƒ', occupied: false});
            
            return {x:bx, y:2, z:bz, width:w, depth:d, height:h, owner:'Ø§Ù„Ù…Ù„Ùƒ'};
        }

        function buildManyHouses(cx, cz, r) {
            const size = 10;
            const gap = 16;
            for(let i=-2; i<=2; i++) {
                for(let j=-2; j<=2; j++) {
                    if(Math.abs(i)<=1 && Math.abs(j)<=1) continue; // Ù…Ø³Ø§Ø­Ø© Ù„Ù„Ù‚ØµØ± ÙˆØ§Ù„Ù…Ø±ÙƒØ²
                    const hx = cx + i*gap;
                    const hz = cz + j*gap;
                    if(Math.random()>0.3) buildHouse(hx, 2, hz, size, size);
                }
            }
        }

        function buildHouse(bx, y, bz, w, d) {
            const h = 5;
            const mName = MALE_NAMES[Math.floor(Math.random()*MALE_NAMES.length)];
            const fName = FEMALE_NAMES[Math.floor(Math.random()*FEMALE_NAMES.length)];

            // Ø¬Ø¯Ø±Ø§Ù† ÙˆØ³Ù‚Ù
            for(let i=0; i<w; i++) {
                for(let j=0; j<d; j++) {
                    setBlock(bx+i, y, bz+j, BLOCKS.PLANK); // Ø£Ø±Ø¶ÙŠØ©
                    setBlock(bx+i, y+h, bz+j, BLOCKS.PLANK); // Ø³Ù‚Ù
                }
            }
            for(let ky=1; ky<h; ky++) {
                for(let i=0; i<w; i++) {
                    setBlock(bx+i, y+ky, bz, BLOCKS.WOOD);
                    setBlock(bx+i, y+ky, bz+d-1, BLOCKS.WOOD);
                }
                for(let j=0; j<d; j++) {
                    setBlock(bx, y+ky, bz+j, BLOCKS.WOOD);
                    setBlock(bx+w-1, y+ky, bz+j, BLOCKS.WOOD);
                }
            }
            // Ø¨Ø§Ø¨
            const dx = bx+Math.floor(w/2), dz = bz;
            setBlock(dx, y+1, dz, BLOCKS.AIR); setBlock(dx, y+2, dz, BLOCKS.AIR);
            
            // Ù†ÙˆØ§ÙØ°
            setBlock(bx+2, y+2, bz, BLOCKS.GLASS);
            setBlock(bx+w-2, y+2, bz, BLOCKS.GLASS);

            const house = {
                x:bx, y:y, z:bz, width:w, depth:d, height:h,
                owner: mName, spouse: fName, doorX: dx, doorZ: dz
            };
            doors.push({x:dx, y:y+1, z:dz, isOpen:false, house});
            houses.push(house);
            
            beds.push({x: bx+w/2, y: y+1, z: bz+d/2, owner: mName, spouse: fName, occupied: false});
        }

        // ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª (World) ====================
        function setBlock(x, y, z, id) {
            const k = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if(id === BLOCKS.AIR) world.delete(k);
            else world.set(k, id);
        }
        function getBlock(x, y, z) {
            return world.get(`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`) || BLOCKS.AIR;
        }
        function isSolid(x, y, z) {
            const b = getBlock(x, y, z);
            if (b === BLOCKS.DOOR) {
                // Ù‡Ù„ Ø§Ù„Ø¨Ø§Ø¨ Ù…ÙØªÙˆØ­ØŸ
                const d = doors.find(dd => dd.x===x && (dd.y===y || dd.y+1===y) && dd.z===z);
                if(d && d.isOpen) return false;
            }
            return b !== BLOCKS.AIR && b !== BLOCKS.WATER && b !== BLOCKS.GLASS;
        }

        function updateChunks() {
            // ØªÙ†Ø¸ÙŠÙ
            meshes.forEach(m => {
                scene.remove(m);
                if(m.geometry) m.geometry.dispose();
            });
            meshes = [];

            const groups = {};
            // ØªØ¬Ù…ÙŠØ¹ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
            for(const [key, val] of world) {
                if(!groups[val]) groups[val] = [];
                const [x,y,z] = key.split(',').map(Number);
                
                // Culling Ø¨Ø³ÙŠØ·: Ù„Ø§ ØªØ±Ø³Ù… Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ© ØªÙ…Ø§Ù…Ø§Ù‹
                if(isSolid(x+1,y,z) && isSolid(x-1,y,z) && isSolid(x,y+1,z) &&
                   isSolid(x,y-1,z) && isSolid(x,y,z+1) && isSolid(x,y,z-1)) continue;

                const mat = new THREE.Matrix4().makeTranslation(x,y,z);
                groups[val].push(mat);
            }

            const geo = new THREE.BoxGeometry(1,1,1);
            for(const [type, matrices] of Object.entries(groups)) {
                if(!matrices.length) continue;
                const mesh = new THREE.InstancedMesh(geo, materials[type], matrices.length);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                for(let i=0; i<matrices.length; i++) mesh.setMatrixAt(i, matrices[i]);
                scene.add(mesh);
                meshes.push(mesh);
            }
        }

        // ==================== Ø§Ù„Ø´Ø®ØµÙŠØ§Øª (NPCs) ====================
        function createNPCMesh(gender) {
            const group = new THREE.Group();
            const s = 0.8; // scale
            
            const colorSkin = gender==='female' ? 0xffd1a3 : 0xe0ac69;
            const colorClothes = gender==='female' ? 0xe91e63 : 0x3f51b5;

            const matSkin = new THREE.MeshLambertMaterial({color: colorSkin});
            const matCloth = new THREE.MeshLambertMaterial({color: colorClothes});

            // Ø±Ø£Ø³
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5*s, 0.5*s, 0.5*s), matSkin);
            head.position.y = 1.6*s;
            // Ø¬Ø³Ù…
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6*s, 0.8*s, 0.3*s), matCloth);
            body.position.y = 1.0*s;
            // Ø£Ø±Ø¬Ù„
            const legGeo = new THREE.BoxGeometry(0.25*s, 0.7*s, 0.25*s);
            const legL = new THREE.Mesh(legGeo, matSkin); legL.position.set(-0.15*s, 0.35*s, 0);
            const legR = new THREE.Mesh(legGeo, matSkin); legR.position.set(0.15*s, 0.35*s, 0);

            group.add(head, body, legL, legR);
            group.castShadow = true;
            return group;
        }

        function populateCity() {
            houses.forEach(h => {
                spawnNPC(h, 'male', h.owner);
                spawnNPC(h, 'female', h.spouse);
            });
        }

        function spawnNPC(house, gender, name) {
            const mesh = createNPCMesh(gender);
            mesh.position.set(house.x + house.width/2, house.y+2, house.z + house.depth/2);
            scene.add(mesh);
            
            npcs.push({
                mesh, name, gender, house, health: 100, maxHealth: 100,
                state: 'idle', // idle, walking, sleeping
                target: null,
                waitTime: 0,
                alive: true
            });
        }

        function updateNPCs(dt) {
            const night = isNightTime();
            
            npcs.forEach(npc => {
                if(!npc.alive) return;
                
                // Ù…Ù†Ø·Ù‚ Ø§Ù„Ù†ÙˆÙ… ÙÙŠ Ø§Ù„Ù„ÙŠÙ„
                if(night && npc.state !== 'sleeping') {
                    const bed = beds.find(b => (b.owner === npc.name || b.spouse === npc.name));
                    if(bed) {
                        npc.state = 'sleeping';
                        npc.mesh.position.set(bed.x, bed.y+0.2, bed.z);
                        npc.mesh.rotation.x = -Math.PI/2; // Ø§Ø³ØªÙ„Ù‚Ø§Ø¡
                        npc.mesh.rotation.z = 0;
                        return;
                    }
                } else if (!night && npc.state === 'sleeping') {
                    npc.state = 'idle';
                    npc.mesh.rotation.x = 0;
                    npc.mesh.position.y = npc.house.y + 2;
                    npc.target = null;
                }

                if(npc.state === 'sleeping') return;

                // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ¬ÙˆØ§Ù„ (Wandering Logic)
                if(npc.waitTime > 0) {
                    npc.waitTime -= dt;
                } else {
                    if(!npc.target) {
                        // Ø§Ø®ØªÙŠØ§Ø± Ù‡Ø¯Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù‚Ø±ÙŠØ¨
                        const r = 10;
                        const tx = npc.house.x + (Math.random()*r*2 - r);
                        const tz = npc.house.z + (Math.random()*r*2 - r);
                        // ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‡Ø¯Ù Ù„ÙŠØ³ Ø¯Ø§Ø®Ù„ Ø¬Ø¯Ø§Ø±
                        if(!isSolid(tx, npc.house.y+1, tz)) {
                            npc.target = new THREE.Vector3(tx, npc.house.y+2, tz);
                        }
                    } else {
                        // Ø§Ù„Ø­Ø±ÙƒØ© Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù
                        const dir = new THREE.Vector3().subVectors(npc.target, npc.mesh.position);
                        dir.y = 0;
                        const dist = dir.length();
                        
                        if(dist < 0.5) {
                            npc.target = null;
                            npc.waitTime = Math.random() * 5 + 2; // Ø§Ù†ØªØ¸Ø§Ø± 2-7 Ø«ÙˆØ§Ù†ÙŠ
                        } else {
                            dir.normalize();
                            const speed = 2.0 * dt;
                            npc.mesh.position.addScaledVector(dir, speed);
                            npc.mesh.lookAt(npc.target);
                        }
                    }
                }
                
                // Ø¬Ø§Ø°Ø¨ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
                const gy = npc.house.y + 2; // Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø£Ø±Ø¶ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠ
                if(npc.mesh.position.y > gy) npc.mesh.position.y = gy;
            });
        }

        // ==================== Ø§Ù„ÙˆØ­ÙˆØ´ ====================
        function spawnMonsters() {
            if(monsters.length >= 10 || !isNightTime()) return;
            // Ø§Ø®ØªØ± Ø¨ÙˆØ§Ø¨Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
            if(gateBlocks.length) {
                const g = gateBlocks[Math.floor(Math.random()*gateBlocks.length)];
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 1.8, 0.8),
                    new THREE.MeshLambertMaterial({color: 0x2e7d32}) // ÙˆØ­Ø´ Ø£Ø®Ø¶Ø±
                );
                mesh.position.set(g.x, g.y+1, g.z);
                scene.add(mesh);
                monsters.push({mesh, health: 50, active: true});
            }
        }

        function updateMonsters(dt) {
            const day = !isNightTime();
            monsters.forEach((m, i) => {
                if(!m.active) return;
                
                if(day) {
                    m.health -= dt * 10; // ÙŠØ­ØªØ±Ù‚ ÙÙŠ Ø§Ù„Ù†Ù‡Ø§Ø±
                    m.mesh.material.color.setHex(0xff0000); // Ù„ÙˆÙ† Ø£Ø­Ù…Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø­ØªØ±Ø§Ù‚
                }

                if(m.health <= 0) {
                    scene.remove(m.mesh);
                    m.active = false;
                    return;
                }

                // Ù…Ø·Ø§Ø±Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
                const dist = m.mesh.position.distanceTo(player.pos);
                if(dist < 30) {
                    const dir = new THREE.Vector3().subVectors(player.pos, m.mesh.position);
                    dir.y = 0;
                    dir.normalize();
                    m.mesh.position.addScaledVector(dir, 3.5 * dt);
                    m.mesh.lookAt(player.pos);

                    if(dist < 1.5) {
                        player.health -= dt * 15;
                        updateUI();
                        if(player.health <= 0) respawn();
                    }
                }
            });
            monsters = monsters.filter(m => m.active);
            if(Math.random() < 0.01) spawnMonsters();
        }

        function respawn() {
            player.health = 100;
            if(kingHouse) player.pos.set(kingHouse.x+10, kingHouse.y+5, kingHouse.z+10);
            showNotification("Ù„Ù‚Ø¯ Ù‚ÙØªÙ„Øª! Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚ØµØ±...");
            updateUI();
        }

        // ==================== Ø§Ù„ØªÙØ§Ø¹Ù„ ÙˆØ§Ù„ØªØ­ÙƒÙ… ====================
        function setupControls() {
            controls = new PointerLockControls(camera, document.body);
            
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => {
                document.getElementById('overlay').style.display = 'none';
                controls.lock();
                if(audioContext.state === 'suspended') {
                    audioContext.resume().then(createAmbientSound);
                }
            });
            controls.addEventListener('unlock', () => {
                // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ø°Ø§ Ø£Ø±Ø¯ØªØŒ Ø£Ùˆ ØªØ±ÙƒÙ‡Ø§
            });

            if(!isMobile) {
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mouseup', onMouseUp);
                
                // Ø§Ø®ØªÙŠØ§Ø± Ø£Ø¯Ø§Ø© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
                document.addEventListener('keydown', (e) => {
                    const num = parseInt(e.key);
                    if(num >= 1 && num <= 7) selectSlot(num-1);
                });
            } else {
                setupTouchControls();
            }
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': keys.space = true; break;
                case 'ShiftLeft': keys.shift = true; break;
                case 'KeyF': player.flying = !player.flying; break;
                case 'KeyE': interact(); break;
                case 'KeyQ': attack(); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
                case 'ShiftLeft': keys.shift = false; break;
            }
        }

        function onMouseDown(e) {
            if(!controls.isLocked && !isMobile) return;
            if(e.button === 0) { // Ø§Ù„ÙŠØ³Ø§Ø±: ÙƒØ³Ø±
                isBreaking = true;
                startBreaking();
            } else if(e.button === 2) { // Ø§Ù„ÙŠÙ…ÙŠÙ†: Ø¨Ù†Ø§Ø¡
                placeBlock();
            }
        }
        function onMouseUp() {
            isBreaking = false;
            breakProgress = 0;
            breakingBlock = null;
            document.getElementById('break-progress').style.display = 'none';
        }

        // Ø§Ù„Ù…Ù†Ø·Ù‚
        function startBreaking() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(meshes);
            if(intersects.length > 0) {
                const i = intersects[0];
                const m = new THREE.Matrix4();
                i.object.getMatrixAt(i.instanceId, m);
                const p = new THREE.Vector3().setFromMatrixPosition(m);
                breakingBlock = `${Math.floor(p.x)},${Math.floor(p.y)},${Math.floor(p.z)}`;
                document.getElementById('break-progress').style.display = 'block';
            }
        }

        function placeBlock() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            
            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø´Ø®ØµÙŠØ©
            const npcMeshes = npcs.map(n => n.mesh);
            const hitNPC = raycaster.intersectObjects(npcMeshes, true);
            if(hitNPC.length > 0 && hitNPC[0].distance < 4) {
                interact(); // Ø¥Ø°Ø§ Ù†Ù‚Ø±Ù†Ø§ Ø¹Ù„Ù‰ Ø´Ø®ØµÙŠØ© Ø¨Ø§Ù„Ø®Ø·Ø£ØŒ Ù†ØªÙØ§Ø¹Ù„ Ù…Ø¹Ù‡Ø§ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¨Ù†Ø§Ø¡
                return;
            }

            const intersects = raycaster.intersectObjects(meshes);
            if(intersects.length > 0) {
                const i = intersects[0];
                if(i.distance > 8) return; // Ø¨Ø¹ÙŠØ¯ Ø¬Ø¯Ø§Ù‹

                const p = i.point.add(i.face.normal.multiplyScalar(0.5));
                const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
                
                // Ø¹Ø¯Ù… Ø§Ù„Ø¨Ù†Ø§Ø¡ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù„Ø§Ø¹Ø¨
                const pdx = Math.abs(bx - player.pos.x);
                const pdz = Math.abs(bz - player.pos.z);
                const pdy = player.pos.y - by;
                if (pdx < 0.6 && pdz < 0.6 && pdy > -1 && pdy < 1.8) return;

                setBlock(bx, by, bz, selectedBlock);
                updateChunks();
            }
        }

        function interact() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø´Ø®ØµÙŠØ§Øª
            const npcMeshes = npcs.filter(n=>n.alive).map(n=>n.mesh);
            const hits = raycaster.intersectObjects(npcMeshes, true);
            
            if(hits.length > 0 && hits[0].distance < 5) {
                const obj = hits[0].object;
                const npc = npcs.find(n => n.mesh === obj.parent || n.mesh === obj);
                if(npc) showNPCInfo(npc);
            } else {
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ø¨ÙˆØ§Ø¨
                const hitsBlock = raycaster.intersectObjects(meshes);
                if(hitsBlock.length > 0 && hitsBlock[0].distance < 4) {
                    // Ù…Ù†Ø·Ù‚ ÙØªØ­ Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨ (Ù…Ø¨Ø³Ø· Ù‡Ù†Ø§ ÙÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ)
                }
            }
        }

        function attack() {
            // ØªØ£Ø«ÙŠØ± Ø¨ØµØ±ÙŠ
            const weapon = document.createElement('div');
            weapon.style.position = 'absolute';
            weapon.style.right = '20%'; weapon.style.bottom = '20%';
            weapon.style.fontSize = '80px';
            weapon.style.transition = 'all 0.1s';
            weapon.innerText = 'âš”ï¸';
            document.body.appendChild(weapon);
            setTimeout(() => { weapon.style.transform = 'rotate(-45deg) translate(-20px, 20px)'; }, 10);
            setTimeout(() => weapon.remove(), 200);

            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            // Ø¶Ø±Ø¨ Ø§Ù„ÙˆØ­ÙˆØ´
            // (ØªÙ… ØªØ¨Ø³ÙŠØ· Ø§Ù„ÙƒÙˆØ¯: ÙÙŠ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Raycast Ù„Ù„ÙˆØ­ÙˆØ´)
            const monsterMeshes = monsters.map(m=>m.mesh);
            const hits = raycaster.intersectObjects(monsterMeshes);
            if(hits.length > 0 && hits[0].distance < 4) {
                const m = monsters.find(mo => mo.mesh === hits[0].object);
                if(m) {
                    m.health -= 20;
                    showNotification("Ø¶Ø±Ø¨Øª ÙˆØ­Ø´Ø§Ù‹!");
                }
            }
        }

        // ==================== ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ====================
        function createHotbar() {
            const container = document.getElementById('hotbar-container');
            const items = [
                {id: BLOCKS.BRICK, t: 'ğŸ§±'}, {id: BLOCKS.COBBLESTONE, t: 'ğŸª¨'},
                {id: BLOCKS.PLANK, t: 'ğŸªµ'}, {id: BLOCKS.GLASS, t: 'ğŸªŸ'},
                {id: BLOCKS.TORCH, t: 'ğŸ”¦'}, {id: BLOCKS.GRASS, t: 'ğŸŒ¿'},
                {id: BLOCKS.DIRT, t: 'ğŸŸ«'}
            ];
            items.forEach((it, i) => {
                const el = document.createElement('div');
                el.className = 'slot' + (i===0?' active':'');
                el.innerText = it.t;
                el.onclick = () => selectSlot(i);
                el.style.backgroundColor = BLOCK_COLORS[it.id];
                container.appendChild(el);
            });
        }

        function selectSlot(i) {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(s => s.classList.remove('active'));
            if(slots[i]) slots[i].classList.add('active');
            
            const types = [BLOCKS.BRICK, BLOCKS.COBBLESTONE, BLOCKS.PLANK, BLOCKS.GLASS, BLOCKS.TORCH, BLOCKS.GRASS, BLOCKS.DIRT];
            selectedBlock = types[i] || BLOCKS.BRICK;
        }

        function showNPCInfo(npc) {
            document.getElementById('npc-name').innerText = npc.name;
            document.getElementById('npc-gender').innerText = npc.gender==='male'?'Ø°ÙƒØ±':'Ø£Ù†Ø«Ù‰';
            document.getElementById('npc-status').innerText = npc.alive?'Ø­ÙŠ':'Ù…ÙŠØª';
            document.getElementById('npc-spouse').innerText = npc.name === 'Ø§Ù„Ù…Ù„Ùƒ' ? '-' : (npc.house.spouse || 'Ø£Ø¹Ø²Ø¨');
            document.getElementById('npc-health').innerText = npc.health;
            
            const btn = document.getElementById('marry-btn');
            if(npc.gender === 'female' && !player.wives.includes(npc.name)) {
                btn.style.display = 'block';
                btn.onclick = () => {
                    player.wives.push(npc.name);
                    showNotification(`ğŸ‰ ØªÙ… Ø§Ù„Ø²ÙˆØ§Ø¬ Ù…Ù† ${npc.name}!`);
                    document.getElementById('wives-count').innerText = player.wives.length;
                    document.getElementById('npc-info-modal').style.display = 'none';
                };
            } else {
                btn.style.display = 'none';
            }

            document.getElementById('attack-npc-btn').onclick = () => {
                npc.health = 0;
                npc.alive = false;
                scene.remove(npc.mesh);
                showNotification("ğŸ˜± Ù„Ù‚Ø¯ Ù‚ØªÙ„Øª Ù…ÙˆØ§Ø·Ù†Ø§Ù‹!");
                document.getElementById('npc-info-modal').style.display = 'none';
            };

            document.getElementById('close-modal-btn').onclick = () => {
                document.getElementById('npc-info-modal').style.display = 'none';
            };
            
            document.getElementById('npc-info-modal').style.display = 'block';
            document.exitPointerLock();
        }

        function updateUI() {
            document.getElementById('health-fill').style.width = player.health + '%';
            document.getElementById('health-text').innerText = Math.ceil(player.health) + ' / 100';
            document.getElementById('time-display').innerText = getTimeString();
        }

        function showNotification(msg) {
            const n = document.getElementById('notification');
            n.innerText = msg;
            n.style.display = 'block';
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
            n.style.animation = 'none';
            n.offsetHeight; /* trigger reflow */
            n.style.animation = 'fadeInOut 3s forwards';
        }

        // ==================== Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© (Game Loop) ====================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.1);
            gameTime += dt / DAY_CYCLE_DURATION;

            // ØªØ­Ø¯ÙŠØ«Ø§Øª
            updateSky();
            updatePhysics(dt);
            updateNPCs(dt);
            updateMonsters(dt);
            updateDoors();
            updateUI();

            // ÙƒØ³Ø± Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª
            if(isBreaking && breakingBlock) {
                breakProgress += dt * 100 / BREAK_TIME;
                document.getElementById('break-fill').style.width = breakProgress + '%';
                if(breakProgress >= 100) {
                    const [x,y,z] = breakingBlock.split(',').map(Number);
                    setBlock(x,y,z, BLOCKS.AIR);
                    updateChunks();
                    isBreaking = false;
                    document.getElementById('break-progress').style.display = 'none';
                }
            }

            renderer.render(scene, camera);
        }

        function updatePhysics(dt) {
            const speed = player.flying ? SPEED_FLY : SPEED_WALK;
            
            // Ø­Ø³Ø§Ø¨ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            fwd.y=0; fwd.normalize();
            right.y=0; right.normalize();

            let dx=0, dz=0;
            if(keys.w) dz += 1;
            if(keys.s) dz -= 1;
            if(keys.a) dx -= 1;
            if(keys.d) dx += 1;
            
            // Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø§ÙˆØ³ ÙˆØ§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯
            if(isMobile) {
                dx += joystickMove.x; dz += -joystickMove.y;
            }

            const move = new THREE.Vector3().addScaledVector(fwd, dz).addScaledVector(right, dx);
            if(move.length() > 0) move.normalize().multiplyScalar(speed);
            
            player.vel.x = move.x;
            player.vel.z = move.z;

            // Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ© ÙˆØ§Ù„Ù‚ÙØ²
            if(player.flying) {
                player.vel.y = 0;
                if(keys.space) player.vel.y = speed;
                if(keys.shift) player.vel.y = -speed;
            } else {
                player.vel.y -= GRAVITY * dt;
                if(player.onGround && keys.space) {
                    player.vel.y = JUMP_FORCE;
                    player.onGround = false;
                }
            }

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ø¹ Ø§Ù„ØªØµØ§Ø¯Ù…
            player.pos.x += player.vel.x * dt;
            if(checkCol(player.pos)) player.pos.x -= player.vel.x * dt;

            player.pos.z += player.vel.z * dt;
            if(checkCol(player.pos)) player.pos.z -= player.vel.z * dt;

            player.pos.y += player.vel.y * dt;
            
            // ØªØµØ§Ø¯Ù… Ø§Ù„Ø£Ø±Ø¶
            if(checkCol(player.pos)) {
                if(player.vel.y < 0) {
                    player.onGround = true;
                    player.pos.y = Math.ceil(player.pos.y - PLAYER_HEIGHT) + PLAYER_HEIGHT;
                } else if(player.vel.y > 0) {
                    player.pos.y = Math.floor(player.pos.y) - 0.1;
                }
                player.vel.y = 0;
            } else {
                player.onGround = false;
            }

            if(player.pos.y < -20) respawn();
            camera.position.copy(player.pos);
        }

        function checkCol(p) {
            const r = 0.3; // Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ù„Ø§Ø¹Ø¨
            // ÙØ­Øµ Ù†Ù‚Ø§Ø· Ø­ÙˆÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨
            const points = [
                new THREE.Vector3(p.x, p.y-PLAYER_HEIGHT+0.1, p.z), // Ù‚Ø¯Ù…
                new THREE.Vector3(p.x, p.y-0.5, p.z), // ÙˆØ³Ø·
                new THREE.Vector3(p.x, p.y-0.1, p.z) // Ø±Ø£Ø³
            ];
            for(let pt of points) {
                if(isSolid(Math.floor(pt.x), Math.floor(pt.y), Math.floor(pt.z)) ||
                   isSolid(Math.floor(pt.x+r), Math.floor(pt.y), Math.floor(pt.z)) ||
                   isSolid(Math.floor(pt.x-r), Math.floor(pt.y), Math.floor(pt.z)) ||
                   isSolid(Math.floor(pt.x), Math.floor(pt.y), Math.floor(pt.z+r)) ||
                   isSolid(Math.floor(pt.x), Math.floor(pt.y), Math.floor(pt.z-r))) return true;
            }
            return false;
        }

        function updateDoors() {
            // ÙØªØ­ Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„Ù‚Ø±Ø¨
            doors.forEach(d => {
                const dist = Math.sqrt((player.pos.x-d.x)**2 + (player.pos.z-d.z)**2);
                const shouldOpen = dist < 2.5;
                if(d.isOpen !== shouldOpen) {
                    d.isOpen = shouldOpen;
                    // ØªØ­Ø¯ÙŠØ« Ø¨ØµØ±ÙŠ Ø¨Ø³ÙŠØ·: Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¨Ø§Ø¨ Ø¹Ù†Ø¯ Ø§Ù„ÙØªØ­
                    if(shouldOpen) {
                        setBlock(d.x, d.y, d.z, BLOCKS.AIR);
                        setBlock(d.x, d.y+1, d.z, BLOCKS.AIR);
                    } else {
                        setBlock(d.x, d.y, d.z, BLOCKS.DOOR);
                        setBlock(d.x, d.y+1, d.z, BLOCKS.DOOR);
                    }
                    updateChunks(); // Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ø§ Ù…ÙƒÙ„ÙØŒ ÙÙŠ Ù„Ø¹Ø¨Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù†Ø­Ø±Ùƒ Ø§Ù„Ù€ Mesh ÙÙ‚Ø·
                }
            });

            // Ø¨ÙˆØ§Ø¨Ø§Øª Ø§Ù„Ø³ÙˆØ± ØªÙØªØ­ ÙÙŠ Ø§Ù„Ù†Ù‡Ø§Ø± ÙˆØªØºÙ„Ù‚ ÙÙŠ Ø§Ù„Ù„ÙŠÙ„
            const night = isNightTime();
            if(gatesOpen === night) { // Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ø¹ÙƒÙˆØ³Ø© Ø¹Ù…Ø§ ÙŠØ¬Ø¨
                gatesOpen = !night;
                gateBlocks.forEach(g => {
                    setBlock(g.x, g.y, g.z, gatesOpen ? BLOCKS.AIR : BLOCKS.DOOR);
                });
                updateChunks();
                showNotification(gatesOpen ? "â˜€ï¸ ÙÙØªØ­Øª Ø¨ÙˆØ§Ø¨Ø§Øª Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©" : "ğŸŒ™ Ø£ÙØºÙ„Ù‚Øª Ø§Ù„Ø¨ÙˆØ§Ø¨Ø§Øª Ù„Ù„Ø­Ù…Ø§ÙŠØ©");
            }
        }

        function setupTouchControls() {
            // ÙƒÙˆØ¯ Ø¹ØµØ§ Ø§Ù„ØªØ­ÙƒÙ… (Joystick) Ø§Ù„Ø¨Ø³ÙŠØ·
            const handle = (id, cb) => {
                const el = document.getElementById(id);
                const stick = el.querySelector('.stick');
                let startX, startY;
                el.addEventListener('touchstart', e => {
                    const t = e.changedTouches[0];
                    startX = t.clientX; startY = t.clientY;
                });
                el.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const t = e.changedTouches[0];
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;
                    const d = Math.min(Math.sqrt(dx*dx+dy*dy), 40);
                    const ang = Math.atan2(dy, dx);
                    const nx = Math.cos(ang)*d, ny = Math.sin(ang)*d;
                    stick.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
                    cb(nx/40, ny/40);
                });
                el.addEventListener('touchend', () => {
                    stick.style.transform = `translate(-50%, -50%)`;
                    cb(0,0);
                });
            };
            handle('joystick-left', (x,y) => { joystickMove.x=x; joystickMove.y=y; });
            handle('joystick-right', (x,y) => { 
                camera.rotation.y -= x * 0.05;
                camera.rotation.x -= y * 0.05;
            });
            
            document.getElementById('jump-btn').ontouchstart = () => keys.space=true;
            document.getElementById('jump-btn').ontouchend = () => keys.space=false;
            document.getElementById('fly-btn').onclick = () => player.flying=!player.flying;
            document.getElementById('attack-btn').onclick = attack;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
